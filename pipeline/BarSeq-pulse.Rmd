---
title: "Analysis of competition experiments with a barcoded transposon library"
date: "`r format(Sys.time(), '%d %B, %Y')`"
author: "Michael Jahn"
output:
  html_notebook: 
    theme: spacelab
    toc: yes
---

## Description

This R notebook is a bioinformatics pipeline to analyze fitness data obtained from a barcoded transposon library in *Ralstonia eutropha* a.k.a. *Cupriavidus necator*. For background and details regarding the method, see [Wetmore at al., mBio, 2015](https://mbio.asm.org/content/6/3/e00306-15) and [Price et al., Nature, 2018](http://www.nature.com/articles/s41586-018-0124-0)).


## Libraries

```{r, message = FALSE}
# optionally install repos from github
# devtools::install_github("m-jahn/lattice-tools")
library(lattice)
library(latticeExtra)
library(latticetools)
library(tidyverse)
library(ggvenn)
```


## Overview of barcode/transposon read counts

### Data import and processing

Read in the main data table with reads per barcode and sample ('pool counts'), and the fitness table. Tables were obtained by processing sequencing data with a custom [BarSeq pipeline](https://github.com/m-jahn/rebar). We remove the 32 generations sequencing samples due to the low read count in the `continuous` samples.

```{r, message = FALSE}
# import barseq counts data in wide format
df_barseq <- read_tsv("../data/barseq/20201222_barseq_frc.poolcount") %>%
  select(!matches("32gen|_32_"))

# import fitness data, the final output of the BarSeq pipeline
df_fitness <- read_tsv("../data/barseq/20201222_barseq_frc.gene_fitness.tab") %>%
  mutate(Time = Time %>% str_remove(" generations") %>% as.numeric) %>%
  rename(locus_tag = locusId) %>%
  mutate(Condition = factor(Condition, c("continuous", "short pulse", "long pulse"))) %>%
  filter(Time != 32)

# import genome annotation
df_ref <- read_csv("../data/ref/Ralstonia_H16_genome_annotation.csv") %>%
  filter(!duplicated(locus_tag))

# define standard colors
stdcol <- custom.colorblind()$superpose.line$col
```

### Summary statistics

Convert pool counts table from wide to long format first.
Generate an overview about the number of reads per barcode, barcodes per gene and so on. Around 8-10 M reads were mapped on average, per sample. The Continuous cultivation, 32 generation time point is an outlier, with a lower number of "usable" reads accoridng to the BarSeq pipeline. The total number of sequenced reads is however similar to the other samples; it is not clear yet why 50-70% of reads got discarded for the 32 generation sample.

```{r, message = FALSE}
df_barseq <- df_barseq %>%
  gather(key = "condition", value = "n_reads", matches("Cont|Long|Short"))

# Number of total mapped reads
df_barseq %>% group_by(condition) %>%
  summarize(n_million_reads = sum(n_reads)/10^6)
```

Distribution of **number of reads per barcode**. There are sufficient reads for quantification, on average log2(n) = 5 = 32 reads per barcode were used. This is better coverage then what was obtained with the TnSeq sequencing runs. 

```{r, fig.width = 8, fig.height = 5.5}
plot_reads_per_bc <- histogram(~ log2(n_reads) | condition,
  df_barseq, as.table = TRUE, layout = c(8,5),
  par.settings = custom.colorblind(),
  between = list(x = 0.5, y = 0.5),
  xlab = expression("log"[2]*" reads per barcode"),
  scales = list(alternating = FALSE),
  panel = function(x, ...) {
    panel.grid(h = -1, v = -1, col = grey(0.9))
    panel.histogram(x, border = "white", ...)
  }
)

print(plot_reads_per_bc)
```
Similarly to the above, this is an overview about the **number of barcodes per gene**, as a histogram.
This distribution is the same for all conditions and replicates. The second plot is the **number of reads per gene**, averaged as median over all conditions (excluding 0 time point where counts were averaged by BarSeq pipeline). The average reads per gene are log2(n) = 10, so n = 2^10 or around 1000 reads per gene.


```{r, fig.width = 7, fig.height = 3.7, message = FALSE}
plot_reads_per_bc <- histogram(~ Strains_per_gene,
  df_fitness %>% select(locus_tag, Strains_per_gene) %>% distinct %>% filter(Strains_per_gene < 40), 
  as.table = TRUE, breaks = 20,
  par.settings = custom.colorblind(),
  between = list(x = 0.5, y = 0.5), xlim=c(-2, 42),
  xlab = expression("mutants per gene"),
  scales = list(alternating = FALSE),
  panel = function(x, ...) {
    panel.grid(h = -1, v = -1, col = grey(0.9))
    panel.histogram(x, border = "white", ...)
    panel.ablineq(v = mean(x, na.rm = TRUE),
      fontfamily = "FreeSans", col = grey(0.5), lwd = 2, lty = 2)
  }
)

plot_reads_per_gene <- histogram(~ log2(reads_per_gene_median),
  df_fitness %>% filter(Time != 0) %>% group_by(locus_tag) %>%
    summarize(reads_per_gene_median = median(Counts)),
  as.table = TRUE, breaks = 20,
  par.settings = custom.colorblind(),
  between = list(x = 0.5, y = 0.5),
  xlab = expression("log"[2]*" reads per gene (med)"),
  scales = list(alternating = FALSE),
  panel = function(x, ...) {
    panel.grid(h = -1, v = -1, col = grey(0.9))
    panel.histogram(x, border = "white", ...)
    panel.ablineq(v = mean(x[!is.infinite(x)]),
      fontfamily = "FreeSans", col = grey(0.5), lwd = 2, lty = 2)
  }
)

print(plot_reads_per_bc, split = c(1,1,2,1), more = TRUE)
print(plot_reads_per_gene, split = c(2,1,2,1))
```

One final technical parameter that is useful to assess the necessary sequencing depth is the number of genes that have been reliably quantified in all samples, meaning with a certain minimum number of reads. For this purpose, we exclude one empty sample `ShortPulse_32_gen` and the continuous samples 16 and 32 generations with lower read number/diversity.

```{r, fig.with = 4, fig.height = 3, message = FALSE}
df_fitness %>% filter(!(Condition == "continuous" & Time == 16)) %>%
  group_by(locus_tag) %>%
  summarize(geq_1_reads = sum(Counts >= 1), geq_10_reads = sum(Counts >= 10), 
    geq_100_reads = sum(Counts >= 100)) %>%
  
  xyplot(sort(geq_1_reads) + sort(geq_10_reads) + sort(geq_100_reads) ~ seq_along(locus_tag), .,
    xlab = "gene", ylab = "samples with n or more reads",
    par.settings = custom.colorblind(),
    type = "l", lwd = 2,
      panel = function(x, y, ...) {
      panel.grid(h = -1, v = -1, col = grey(0.9))
      panel.xyplot(x, y, ...)
      panel.key(labels = c("n = 1", "n = 10", "n = 100"), corner = c(0.9,0.1))
    }
  )
```

## Gene fitness analysis

### Depletion over time (generations)

To track the depletion over time (several generations), it's good to keep the 0-time point samples in the same format instead of in a separate column. We move `n0` to `Counts` and fill `log2FC`, `Norm_fg` (normalized fitness per gene), and t-statisitic columns with zeroes.

TODO-List for improvements of `rebar` pipeline:
- keep 0 time point counts, plus replicates in main table
- replace 0 counts with NA by default

```{r}
df_fitness <- df_fitness %>% filter(Time == 8) %>%
  mutate(Counts = n0, .keep = "unused") %>%
  mutate(log2FC = 0, Time = 0, Norm_fg = 0, t = 0, Significant = 0) %>%
  bind_rows(select(df_fitness, -n0)) %>%
  select(-ID) %>%
  left_join(select(df_ref, locus_tag, gene_name, 
    COG_Process, eggNOG_name))
```

Now we can plot log2 FC or normalized gene fitness over generations. For this type of overview it is best to summarize individual replicates (4x) to the mean or median, per time point and condition. We also add genome annotation to the summary table.

```{r, messages = FALSE}
df_fitness_summary <- df_fitness %>% group_by(locus_tag, scaffold, Time, Condition, Strains_per_gene) %>%
  summarize(
    Norm_fg_median = median(Norm_fg, na.rm = TRUE),
    log2FC_median = median(log2FC, na.rm = TRUE),
    tstat_median = median(t, na.rm = TRUE)
  ) %>%
  left_join(df_ref)
```


```{r, fig.width = 6.5, fig.height = 5}
plot_hist_log2FC <- df_fitness_summary %>%
  group_by(Condition, locus_tag) %>% filter(all(!is.infinite(log2FC_median))) %>%
  ungroup %>% slice(1:5000) %>%
  
  xyplot(log2FC_median ~ Time | Condition, .,
    groups = locus_tag, as.table = TRUE,
    col = stdcol[1], alpha = 0.2, layout = c(3, 1),
    xlab = "", ylab = expression("log"[2]*" FC"),
    par.settings = custom.colorblind(), type = c("l"),
    between = list(x = 0.5, y = 0.5),
    scales = list(alternating = FALSE), lwd = 2,
    panel = function(x, y, ...) {
      panel.grid(h = -1, v = -1, col = grey(0.9))
      panel.xyplot(x, y, ...)
    }
  )

plot_hist_normfg <- df_fitness_summary %>%
  ungroup %>% slice(1:5000) %>%
  
  xyplot(Norm_fg_median ~ Time | Condition, .,
    groups = locus_tag, as.table = TRUE,
    col = stdcol[2], alpha = 0.2, layout = c(3, 1),
    xlab = "generations", ylab = "fitness",
    par.settings = custom.colorblind(), type = c("l"),
    between = list(x = 0.5, y = 0.5),
    scales = list(alternating = FALSE), lwd = 2,
    panel = function(x, y, ...) {
      panel.grid(h = -1, v = -1, col = grey(0.9))
      panel.xyplot(x, y, ...)
    }
  )

print(plot_hist_log2FC, position = c(0,0.47,1,1), more = TRUE)
print(plot_hist_normfg, position = c(0,0,1,0.55))
```

As sort of an internal control, compare the gene fitness obtained by a complex procedure to the log2 FC of read counts, which is a very simple measure of 'fitness'. The two variables correlate well for two out of the three conditions, but show a marked difference for "continuous". This can be related to the poorer Seq quality of the 32 generation sample.

```{r, fig.height = 3, fig.width = 6.5}
df_fitness_summary %>%
  group_by(Condition, locus_tag) %>% 
  filter(Time == 8, all(!is.infinite(log2FC_median))) %>%
  ungroup %>% slice(1:5000) %>%
  
  xyplot(Norm_fg_median ~ log2FC_median | Condition, .,
    as.table = TRUE, col = stdcol[5], pch = 19,
    alpha = 0.5, cex = 0.6, aspect = 1,
    layout = c(3, 1), xlim = c(-7,3), ylim = c(-5,5),
    xlab = expression("log"[2]*" FC"), ylab = "fitness",
    par.settings = custom.colorblind(),
    between = list(x = 0.5, y = 0.5),
    scales = list(alternating = FALSE),
    panel = function(x, y, ...) {
      panel.grid(h = -1, v = -1, col = grey(0.9))
      panel.xyplot(x, y, ...)
      panel.lmlineq(x, y, fontfamily = "FreeSans", r.squared = TRUE, ...)
      panel.abline(a = 2, b = 1, col = grey(0.5), lty = 2, lwd = 1.5)
    }
  )
```

### Comparing gene fitness between conditions

Similarly to Figure 2 in [Wetmore et al, mBIO, 2015](https://mbio.asm.org/content/6/3/e00306-15), we can investigate condition-dependent gene fitness by comparing conditions one-on-one.

```{r, fig.width = 9, fig.height = 3.3, message = FALSE}
df_fitness_comp <- df_fitness_summary %>% filter(Time == 8) %>%
  group_by(locus_tag) %>% mutate(tstat_median = min(tstat_median)) %>%
  select(locus_tag, Condition, Norm_fg_median, gene_name, COG_Process, tstat_median) %>%
  pivot_wider(names_from = Condition, values_from = Norm_fg_median)

# plot all conditions vs each other
plot_fitness_comp <- lapply(
  list(
    c("short pulse", "continuous"),
    c("long pulse", "continuous"),
    c("short pulse", "long pulse")), function(var){
  
  xyplot(get(var[1]) ~ get(var[2]),
    df_fitness_comp, groups = abs(get(var[1])-get(var[2])) > 2, #tstat_median < -3
    par.settings = custom.colorblind(), col = stdcol[c(5,1)],
    pch = 19, alpha = 0.5, cex = 0.6, aspect = 1,
    xlim = c(-7, 4), ylim = c(-7, 4),
    xlab = var[2], ylab = var[1],
    panel = function(x, y, ...) {
      panel.grid(h = -1, v = -1, col = grey(0.9))
      panel.abline(v = 0, h = 0, col = grey(0.5), lty = 2, lwd = 1.5)
      panel.abline(a = 0, b = 1, col = grey(0.5), lty = 2, lwd = 1.5)
      panel.abline(a = 2, b = 1, col = grey(0.5), lty = 2, lwd = 1.5)
      panel.abline(a = -2, b = 1, col = grey(0.5), lty = 2, lwd = 1.5)
      panel.xyplot(x, y, ...)
      panel.key(...)
    }
  )
})

print(plot_fitness_comp[[1]], position = c(0,0,0.33,1), more = TRUE)
print(plot_fitness_comp[[2]], position = c(0.33,0,0.66,1), more = TRUE)
print(plot_fitness_comp[[3]], position = c(0.66,0,1,1))
```

### Differential fitness of selected genes

Most genes correlate in fitness value between conditions. That means, only few genes have a **condition-specific fitness effect**, i.e. increase or decrease fitness of the respective strain in a condition. This section investigates specific genes and their functions that show such differential fitness between conditions.

We can define a differential fitness of 2 between conditions as a threshold value. This is arbitrary and simply encloses roughly 95% of the gene population. A more refined way would be to use a (data-dependent) statistical metric for setting a significance boundary (like confidence interval).

```{r}
# obtain list of differential fitness per gene
df_diff_fitness <- df_fitness_comp %>% mutate(
  SP_CO = abs(`short pulse`-continuous) > 2,
  LP_CO = abs(`long pulse`-continuous) > 2,
  SP_LP = abs(`short pulse`-`long pulse`) > 2
) %>% filter(any(SP_CO, LP_CO, SP_LP)) %>% ungroup

df_diff_fitness %>%
  summarize(
    sum(SP_CO, na.rm = TRUE),
    sum(LP_CO, na.rm = TRUE),
    sum(SP_LP, na.rm = TRUE))
```

Now we can identify overlaps between these gene sets and visualize them through infamous Venn diagrams.

```{r, fig.width = 5, fig.height = 5}
plot_venn <- df_diff_fitness %>% select(SP_CO, LP_CO, SP_LP) %>%
  ggplot() +
  geom_venn(aes(A = SP_CO, B = LP_CO, C = SP_LP), fill_color = stdcol) +
  coord_fixed() + 
  theme_void()

print(plot_venn)
```

### Depletion of selected genes over time

One question is to decide how many generations are sufficient to determine significant differences in fitness. It seems that a second time point such as 16 generations helps to judge if fitness effects are consistent or not. If several time points are available, one can also fit a linear model and compare ANOVA p values and R^2. Here we plot genes that have a **low fitness in all fructose conditions** i.e. that are essential in fructose minimal medium, but not complete medium (the condition the library was created with). The threshold for consistent depletion is fitness <= -2 in all three conditions after 8 generations.


```{r, fig.width = 7, fig.height = 6, message = FALSE}
# general plotting function for fitness as time series
draw_fitness_ts  <- function(data) {
  xyplot(Norm_fg ~ factor(Time) | str_extract(gene_name, "[a-zA-Z0-9_]+"), data,
    groups = Condition, as.table = TRUE, col = stdcol[c(5,3,2)],
    par.settings = custom.colorblind(), type = c("p", "l"),
    xlab = "generations", ylab = "fitness",
    pch = 19, between = list(x = 0.5, y = 0.5),
    scales = list(alternating = FALSE), lwd = 2,
    panel = function(x, y, ...) {
      panel.grid(h = -1, v = -1, col = grey(0.9))
      panel.errbars(x, y, ewidth = 0, ...)
      panel.key(...)
    }
  )
}

# look at genes with differential fitness, remove 16 gen continuous time point
# as it shows low read number / low quality
df_fitness_comp %>%
  filter(continuous <= -2 & `short pulse` <= -2 & `long pulse` <= -2) %>%
  select(locus_tag) %>% inner_join(df_fitness) %>%
  filter(!(Time == 16 & Condition == "continuous")) %>%
  draw_fitness_ts

# export genes that are essential for growth on fructose (but not LB)
df_fitness_comp %>%
  filter(continuous <= -2 & `short pulse` <= -2 & `long pulse` <= -2) %>%
  write_csv("../data/output/essentiality_fructose.csv")
```

### Heatmap of genes with strong fitness effect

To include *all genes*, we can also filter genes by a simple fitness threshold instead of the *differential fitness dF*, which probably gives more comprehensive results. For each sample, lower and upper fitness threshold are defined (or t-statistics) and all genes are plotted with fitness score on a heatmap.

```{r, fig.width = 9, fig.height = 3.5}
# generate colorpalette for heatmap
heat_cols <- colorspace::diverging_hcl(n = 7, h = c(260, 0), c = 100, l = c(50, 90))

# rearrange fitness data to wide format
df_heatmap <- df_fitness_summary %>% filter(Time == 8) %>%
  group_by(locus_tag) %>% filter(any(abs(Norm_fg_median) >= 3)) %>%
  ungroup %>% select(COG_Process, gene_name, Condition, Norm_fg_median) %>% 
  pivot_wider(names_from = Condition, values_from = Norm_fg_median) %>%
  select(COG_Process, gene_name, `long pulse`, `short pulse`, continuous) %>%
  mutate(COG_Process = case_when(
    grepl("Amino|Nucleotide|Coenz", COG_Process) ~ "amino acids, nucleotides, coenzymes",
    grepl("Energy", COG_Process) ~ "energy metabolism",
    grepl("Trans|Post", COG_Process) ~ "transcription, translation",
    TRUE ~ "other"
  )) %>%
  column_to_rownames(var = "gene_name")

# turn matrix into heat map, also for re-ordering
mat_heatmap <- select(df_heatmap, -COG_Process) %>% as.matrix  
reordered <- mat_heatmap %>% dist %>% hclust %>% as.dendrogram %>% 
  order.dendrogram

# plot heatmap
plot_heatmap_1 <- levelplot(mat_heatmap[reordered, ] %>% replace(., . > 6, 6) %>% replace(., . < -6, -6),
  par.settings = custom.colorblind(),
  col.regions = colorRampPalette(heat_cols)(16),
  at = seq(-6, 6, 1), aspect = "fill",
  xlab = "", ylab = "", scales = list(x = list(tck = c(1, 0), cex = 0.6, rot = 90)),
  panel = function(x, y, z, ...) {
    panel.levelplot(x, y, z, ...)
    panel.abline(h = c(1.5, 2.5), col = "white", lwd = 1.5)
  }
)

# plot color coded COG groups
plot_heatmap_2 <- xyplot(rep(1, length(continuous)) ~ seq_along(continuous), df_heatmap[reordered, ],
  groups = COG_Process, par.settings = custom.colorblind(),
  scales = list(draw = FALSE), xlab = "", ylab = "",
  xlim = c(0.25, length(reordered)+0.25), col = stdcol[c(1,2,3,4)],
  pch = 15, cex = 1.1, auto.key = list(columns = 4, cex = 0.7))


print(plot_heatmap_1, position = c(0,0,1,0.92), more = TRUE)
print(plot_heatmap_2, position = c(0.1,0.76,0.92,1))
```


### Fitness per functional group

So far, the **bottom-up approach** was used to select interesting groups of genes. A threshold in fitness score (difference) was applied and the genes tested for enrichment of functional groups.
Here, we will apply the **top-down approach**, first select known groups of interest, and then compare average fitness score for the three conditions. We start with one of the most interesting features of *Ralstonia*, the *cbb* operon encoding enzymes for PPP and Calvin cycle (e.g. Rubisco). Then we look at other genes/groups of interest, like PHB synthesis, or oxidative phosphorylation.

First we come up with a generalized function to compare all genes of a pathway as a beeswarm plot, broken down by condition.

```{r}
draw_beeswarm <- function(data) {
  xyplot(Norm_fg_median ~ Condition, data,
    groups = Condition, col = stdcol[c(5, 2)],
    xlab = "", ylab = "fitness", ylim = c(-3.5, 3.5),
    par.settings = custom.colorblind(), as.table = TRUE,
    between = list(x = 0.5, y = 0.5), pch = 19,
    scales = list(alternating = FALSE),
    panel = function(x, y, ...) {
      panel.grid(h = -1, v = -1, col = grey(0.9))
      panel.abline(h = 0, lwd = 1.5, col = grey(0.7), lty = 2)
      panel.beeswarm(x, y, bin_y = TRUE, spread = 0.13, ...)
    }
  )
}
```

The cbb mutants for chromosome 2 seem to have a more positive fitness score compared to their counter parts on the pHG1 megaplasmid. However, the four genes with higher fitness show suspicious jumps from 8 to 16 hours. A  look up in the summary table revealed that they have only 1 or 2 mutants quantified per gene, which makes the results less reliable, particularly for the continuous condition with the low read problem at 16 gen. It is better to exclude these mutants. The pHG1 copies have 4,5,6 and 6 mutants respectively.

```{r, fig.width = 7.5, fig.height = 2.7}
# beeswarm plots
plot_cbb_fitness_bee <- df_fitness_summary %>%
  filter(Condition != "short pulse", 
    Time == 16, str_detect(gene_name, "cbb.|cfx.|cbx.")) %>%
  mutate(Condition = Condition %>% str_replace("long ", "") %>% factor) %>%
  draw_beeswarm

# single time series per gene
plot_cbb_fitness_select <- df_fitness %>% 
  filter(
    Condition != "short pulse",
    str_detect(gene_name, "(cbb|cfx|cbx)[PSLZKGATE]P|cbbR")) %>%
  mutate(
    Condition = Condition %>% str_replace("long ", "") %>% factor,
    gene_name = case_when(
      gene_name == "cfxR cbbR H16_B1396" ~ "cbbR (REG)",
      gene_name == "cfxP cbbPP PHG421" ~ "cbbP (PRUK)",
      gene_name == "cbxSP cbbS cbbSP cfxSP rbcS PHG426" ~ "cbbS (RBPC)",
      gene_name == "cbbL2 cbbL cbxLP cfxLP PHG427" ~ "cbbL (RBPC)",
      gene_name == "cbbZP PHG419" ~ "cbbZ (PGP)",
      gene_name == "cbbKP PHG417" ~ "cbbK (PGK)",
      gene_name == "cbbGP PHG418" ~ "cbbG (GAPDH)",
      gene_name == "cbbAP PHG416" ~ "cbbA (FBA)",
      gene_name == "cbbTP PHG420" ~ "cbbT (TKT)",
      gene_name == "cbxXP cfxXP PHG425" ~ "cbbX (RBCA)",
      gene_name == "cbbEP cfxE PHG423" ~ "cbbE (RPE)"
    ) %>% factor(., unique(.)[c(1,7,9,10,5,3,4,2,6,8)])
  ) %>%
  
  xyplot(Norm_fg ~ factor(Time) | gene_name, .,
    groups = Condition, as.table = TRUE, col = stdcol[c(5,2)],
    par.settings = custom.colorblind(), type = c("p", "l"),
    xlab = "generations", ylab = "fitness",
    ylim = c(-4, 4), layout = c(5, 2),
    pch = 19, between = list(x = 0.5, y = 0.5),
    scales = list(alternating = FALSE), lwd = 2,
    panel = function(x, y, ...) {
      panel.grid(h = -1, v = -1, col = grey(0.9))
      panel.errbars(x, y, ewidth = 0, ...)
      panel.key(..., cex = 0.6, points = FALSE, corner = c(0, 0.95))
    }
  )

print(plot_cbb_fitness_bee, position = c(0,0.03,0.35,1.1), more = TRUE)
print(plot_cbb_fitness_select, position = c(0.3,0,1.03,1.1))
```

```{r, include = FALSE}
svg("../figures/figure_fitness_cbb.svg", width = 7.5, height = 2.7)
print(plot_cbb_fitness_bee, position = c(0,0.03,0.35,1.1), more = TRUE)
print(plot_cbb_fitness_select, position = c(0.3,0,1.03,1.1))
dev.off()
```
