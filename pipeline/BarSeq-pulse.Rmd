---
title: "Analysis of competition experiments with a barcoded transposon library"
date: "`r format(Sys.time(), '%d %B, %Y')`"
author: "Michael Jahn"
output:
  html_notebook: 
    theme: spacelab
    toc: yes
---

## Description

This R notebook is a bioinformatics pipeline to analyze fitness data obtained from a barcoded transposon library in *Ralstonia eutropha* a.k.a. *Cupriavidus necator*. For background and details regarding the method, see [Wetmore at al., mBio, 2015](https://mbio.asm.org/content/6/3/e00306-15) and [Price et al., Nature, 2018](http://www.nature.com/articles/s41586-018-0124-0)).


## Libraries

```{r, message = FALSE}
# optionally install repos from github
# devtools::install_github("m-jahn/lattice-tools")
library(lattice)
library(latticeExtra)
library(latticetools)
library(tidyverse)
library(ggvenn)
```


## Overview of barcode/transposon read counts

### Data import and processing

Read in the main data table with reads per barcode and sample ('pool counts'), and the fitness table. Tables were obtained by processing sequencing data with a custom [BarSeq pipeline](https://github.com/m-jahn/rebar).

```{r, message = FALSE}
# import barseq counts data in wide format
df_barseq <- read_tsv("../data/barseq/20201222_barseq_frc.poolcount")

# import fitness data, the final output of the BarSeq pipeline
df_fitness <- read_tsv("../data/barseq/20201222_barseq_frc.gene_fitness.tab") %>%
  mutate(Time = Time %>% str_remove(" generations") %>% as.numeric) %>%
  rename(locus_tag = locusId)

# import genome annotation
df_ref <- read_csv("../data/ref/Ralstonia_H16_genome_annotation.csv") %>%
  filter(!duplicated(locus_tag))

# define standard colors
stdcol <- custom.colorblind()$superpose.line$col
```

### Summary statistics

Convert pool counts table from wide to long format first.
Generate an overview about the number of reads per barcode, barcodes per gene and so on. Around 8-10 M reads were mapped on average, per sample. The Continuous cultivation, 32 generation time point is an outlier.

```{r, message = FALSE}
df_barseq <- df_barseq %>% 
  gather(key = "condition", value = "n_reads", matches("Continuous|Long|Short"))

# Number of total mapped reads
df_barseq %>% group_by(condition) %>%
  summarize(n_million_reads = sum(n_reads)/10^6)
```

Distribution of **number of reads per barcode**. There are sufficient reads for quantification, on average log2(n) = 5 = 32 reads per barcode were used. This is better coverage then what was obtained with the TnSeq sequencing runs. 

```{r, fig.width = 9, fig.height = 6}
plot_reads_per_bc <- histogram(~ log2(n_reads) | condition,
  df_barseq, as.table = TRUE, layout = c(8,5),
  par.settings = custom.colorblind(),
  between = list(x = 0.5, y = 0.5),
  xlab = expression("log"[2]*" reads per barcode"),
  scales = list(alternating = FALSE),
  panel = function(x, ...) {
    panel.grid(h = -1, v = -1, col = grey(0.9))
    panel.histogram(x, border = "white", ...)
  }
)

print(plot_reads_per_bc)
```
Similarly to the above, this is an overview about the **number of barcodes per gene**, as a histogram.
This distribution is the same for all conditions and replicates. The second plot is the **number of reads per gene**, averaged as median over all conditions (excluding 0 time point where counts were averaged by BarSeq pipeline). The average reads per gene are log2(n) = 10, so n = 2^10 or around 1000 reads per gene.


```{r, fig.width = 7, fig.height = 3.7, message = FALSE}
plot_reads_per_bc <- histogram(~ Strains_per_gene,
  df_fitness %>% select(locus_tag, Strains_per_gene) %>% distinct %>% filter(Strains_per_gene < 40), 
  as.table = TRUE, breaks = 20,
  par.settings = custom.colorblind(),
  between = list(x = 0.5, y = 0.5), xlim=c(-2, 42),
  xlab = expression("mutants per gene"),
  scales = list(alternating = FALSE),
  panel = function(x, ...) {
    panel.grid(h = -1, v = -1, col = grey(0.9))
    panel.histogram(x, border = "white", ...)
  }
)

plot_reads_per_gene <- histogram(~ log2(reads_per_gene_median),
  df_fitness %>% filter(Time != 0) %>% group_by(locus_tag) %>%
    summarize(reads_per_gene_median = median(Counts)),
  as.table = TRUE, breaks = 20,
  par.settings = custom.colorblind(),
  between = list(x = 0.5, y = 0.5),
  xlab = expression("log"[2]*" reads per gene (med)"),
  scales = list(alternating = FALSE),
  panel = function(x, ...) {
    panel.grid(h = -1, v = -1, col = grey(0.9))
    panel.histogram(x, border = "white", ...)
  }
)

print(plot_reads_per_bc, split = c(1,1,2,1), more = TRUE)
print(plot_reads_per_gene, split = c(2,1,2,1))
```

One final technical parameter that is useful to assess the necessary sequencing depth is the number of genes that have been reliably quantified in all samples, meaning with a certain minimum number of reads. For this purpose, we exclude one empty sample `ShortPulse_32_gen` and the four `Continuous_32_gen` samples with insufficient read number.

```{r, fig.with = 4, fig.height = 3, message = FALSE}
df_fitness %>% filter(!((Condition == "continuous" & Time == 32) | 
  (Condition == "long pulse" & Time == 32 & Replicate == 4))) %>%
  group_by(locus_tag) %>%
  summarize(geq_1_reads = sum(Counts >= 1), geq_10_reads = sum(Counts >= 10), 
    geq_100_reads = sum(Counts >= 100)) %>% 
  
  xyplot(sort(geq_1_reads) + sort(geq_10_reads) + sort(geq_100_reads) ~ seq_along(locus_tag), .,
    xlab = "gene", ylab = "samples with n or more reads",
    par.settings = custom.colorblind(),
    type = "l", lwd = 2,
      panel = function(x, y, ...) {
      panel.grid(h = -1, v = -1, col = grey(0.9))
      panel.xyplot(x, y, ...)
      panel.key(labels = c("n = 1", "n = 10", "n = 100"), corner = c(0.9,0.1))
    }
  )
```

## Gene fitness analysis

### Depletion over time (generations)

To track the depletion over time (several generations), it's good to keep the 0-time point samples in the same format instead of in a separate column. We move `n0` to `Counts` and fill `log2FC` and `Norm_fg` (normalized fitness per gene) columns with zeroes.

TODO-List for improvements of `rebar` pipeline:
- keep 0 time point counts, plus replicates
- replace 0 counts with NA by default

```{r}
df_fitness <- df_fitness %>% filter(Time == 8) %>%
  mutate(Counts = n0, .keep = "unused") %>%
  mutate(log2FC = 0, Time = 0, Norm_fg = 0) %>%
  bind_rows(select(df_fitness, -n0)) %>%
  select(-ID) %>%
  left_join(select(df_ref, locus_tag, gene_name, 
    COG_Process, eggNOG_name))
```

Now we can plot log2 FC or normalized gene fitness over generations. For this type of overview it is best to summarize individual replicates (4x) to the mean or median, per time point and condition. We also add genome annotation to the summary table.

```{r, messages = FALSE}
df_fitness_summary <- df_fitness %>% group_by(locus_tag, scaffold, Time, Condition, Strains_per_gene) %>%
  summarize(
    Norm_fg_median = median(Norm_fg, na.rm = TRUE),
    log2FC_median = median(log2FC, na.rm = TRUE),
    tstat_median = median(t, na.rm = TRUE)
  ) %>%
  left_join(df_ref)
```


```{r, fig.width = 6.5, fig.height = 5}
plot_hist_log2FC <- df_fitness_summary %>%
  group_by(Condition, locus_tag) %>% filter(all(!is.infinite(log2FC_median))) %>%
  ungroup %>% slice(1:5000) %>%
  
  xyplot(log2FC_median ~ Time | Condition, .,
    groups = locus_tag, as.table = TRUE,
    col = stdcol[1], alpha = 0.2, layout = c(3, 1),
    xlab = "", ylab = expression("log"[2]*" FC"),
    par.settings = custom.colorblind(), type = c("l"),
    between = list(x = 0.5, y = 0.5),
    scales = list(alternating = FALSE), lwd = 2,
    panel = function(x, y, ...) {
      panel.grid(h = -1, v = -1, col = grey(0.9))
      panel.xyplot(x, y, ...)
    }
  )

plot_hist_normfg <- df_fitness_summary %>%
  ungroup %>% slice(1:5000) %>%
  
  xyplot(Norm_fg_median ~ Time | Condition, .,
    groups = locus_tag, as.table = TRUE,
    col = stdcol[2], alpha = 0.2, layout = c(3, 1),
    xlab = "generations", ylab = "fitness",
    par.settings = custom.colorblind(), type = c("l"),
    between = list(x = 0.5, y = 0.5),
    scales = list(alternating = FALSE), lwd = 2,
    panel = function(x, y, ...) {
      panel.grid(h = -1, v = -1, col = grey(0.9))
      panel.xyplot(x, y, ...)
    }
  )

print(plot_hist_log2FC, position = c(0,0.47,1,1), more = TRUE)
print(plot_hist_normfg, position = c(0,0,1,0.55))
```

As sort of an internal control, compare the gene fitness obtained by a complex procedure to the log2 FC of read counts, which is a very simple measure of 'fitness'. The two variables correlate well for two out of the three conditions, but show a marked difference for "continuous". This can be related to the poorer Seq quality of the 32 generation sample.

```{r, fig.height = 3, fig.width = 6.5}
df_fitness_summary %>%
  group_by(Condition, locus_tag) %>% 
  filter(Time == 8, all(!is.infinite(log2FC_median))) %>%
  ungroup %>% slice(1:5000) %>%
  
  xyplot(Norm_fg_median ~ log2FC_median | Condition, .,
    as.table = TRUE, col = stdcol[5], pch = 19,
    alpha = 0.5, cex = 0.6, aspect = 1,
    layout = c(3, 1), xlim = c(-7,3), ylim = c(-5,5),
    xlab = expression("log"[2]*" FC"), ylab = "fitness",
    par.settings = custom.colorblind(),
    between = list(x = 0.5, y = 0.5),
    scales = list(alternating = FALSE),
    panel = function(x, y, ...) {
      panel.grid(h = -1, v = -1, col = grey(0.9))
      panel.xyplot(x, y, ...)
      panel.lmlineq(x, y, fontfamily = "FreeSans", r.squared = TRUE, ...)
      panel.abline(a = 2, b = 1, col = grey(0.5), lty = 2, lwd = 1.5)
    }
  )
```

### Comparing gene fitness between conditions

Similarly to Figure 2 in [Wetmore et al, mBIO, 2015](https://mbio.asm.org/content/6/3/e00306-15), we can investigate condition-dependent gene fitness by comparing conditions one-on-one.

```{r, fig.width = 9, fig.height = 3.3, message = FALSE}
df_fitness_comp <- df_fitness_summary %>% filter(Time == 8) %>%
  group_by(locus_tag) %>% mutate(tstat_median = min(tstat_median)) %>%
  select(locus_tag, Condition, Norm_fg_median, gene_name, COG_Process, tstat_median) %>%
  pivot_wider(names_from = Condition, values_from = Norm_fg_median)

# plot all conditions vs each other
plot_fitness_comp <- lapply(
  list(
    c("short pulse", "continuous"),
    c("long pulse", "continuous"),
    c("short pulse", "long pulse")), function(var){
  
  xyplot(get(var[1]) ~ get(var[2]),
    df_fitness_comp, groups = abs(get(var[1])-get(var[2])) > 2, #tstat_median < -3
    par.settings = custom.colorblind(), col = stdcol[c(5,1)],
    pch = 19, alpha = 0.5, cex = 0.6, aspect = 1,
    xlim = c(-7, 4), ylim = c(-7, 4),
    xlab = var[2], ylab = var[1],
    panel = function(x, y, ...) {
      panel.grid(h = -1, v = -1, col = grey(0.9))
      panel.abline(v = 0, h = 0, col = grey(0.5), lty = 2, lwd = 1.5)
      panel.abline(a = 0, b = 1, col = grey(0.5), lty = 2, lwd = 1.5)
      panel.abline(a = 2, b = 1, col = grey(0.5), lty = 2, lwd = 1.5)
      panel.abline(a = -2, b = 1, col = grey(0.5), lty = 2, lwd = 1.5)
      panel.xyplot(x, y, ...)
      panel.key(...)
    }
  )
})

print(plot_fitness_comp[[1]], position = c(0,0,0.33,1), more = TRUE)
print(plot_fitness_comp[[2]], position = c(0.33,0,0.66,1), more = TRUE)
print(plot_fitness_comp[[3]], position = c(0.66,0,1,1))
```

### Differential fitness of selected genes

Most genes correlate in fitness value between conditions. That means, only few genes have a **condition-specific fitness effect**, i.e. increase or decrease fitness of the respective strain in a condition. This section investigates specific genes and their functions that show such differential fitness between conditions.

We can define a differential fitness of 2 between conditions as a threshod value. This is arbitrary and simply encloses roughly 95% of the gene population. A more refined way would be to use a (data-dependent) statistical metric for setting a significance boundary (like confidence interval).

```{r}
# obtain list of differential fitness per gene
df_diff_fitness <- df_fitness_comp %>% mutate(
  SP_CO = abs(`short pulse`-continuous) > 2,
  LP_CO = abs(`long pulse`-continuous) > 2,
  SP_LP = abs(`short pulse`-`long pulse`) > 2
) %>% filter(any(SP_CO, LP_CO, SP_LP)) %>% ungroup

df_diff_fitness %>%
  summarize(
    sum(SP_CO, na.rm = TRUE), 
    sum(LP_CO, na.rm = TRUE), 
    sum(SP_LP, na.rm = TRUE))
```

Now we can identify overlaps between these gene sets and visualize them through infamous Venn diagrams.

```{r, fig.width = 5, fig.height = 5}
plot_venn <- df_diff_fitness %>% select(SP_CO, LP_CO, SP_LP) %>%
  ggplot() +
  geom_venn(aes(A = SP_CO, B = LP_CO, C = SP_LP), fill_color = stdcol) +
  coord_fixed() + 
  theme_void()

print(plot_venn)
```

### Depletion of selected genes over time

Based on the previous step, a set of genes of interest and their depletion/enrichment plotted over time (plotted is normalized gene fitness). The most interesting sets are A) genes with differential fitness for SP vs CO AND LP vs CO. And B) genes with diff. fitness for LP vs SP. For the first set, we are specifically looking for genes that have **lower fitness score** in the pulsed conditions, i.e. genes involved in adaptation to changing conditions.

```{r, fig.width = 8, fig.height = 6, message = FALSE}
# general plotting function for fitness as time series
draw_fitness_ts  <- function(data) {
  xyplot(Norm_fg ~ factor(Time) | str_extract(gene_name, "[a-zA-Z0-9_]+"), data,
    groups = Condition, as.table = TRUE,
    par.settings = custom.colorblind(), type = c("p", "l"),
    xlab = "generations", ylab = "fitness",
    pch = 19, between = list(x = 0.5, y = 0.5),
    scales = list(alternating = FALSE), lwd = 2,
    panel = function(x, y, ...) {
      panel.grid(h = -1, v = -1, col = grey(0.9))
      panel.errbars(x, y, ewidth = 0, ...)
      panel.key(...)
    }
  )
}


df_fitness %>% inner_join(
    filter(df_diff_fitness, SP_CO & LP_CO & !SP_LP) %>% select(locus_tag)
  ) %>%
  draw_fitness_ts
```

### Functional enrichment

And finally investigate their function, or at least enrichment in certain functional groups. What are the dominant COG groups per for the genes of interest?

```{r, message = FALSE}
df_diff_fitness %>% count(COG_Process, sort = TRUE)
```

The largest group is transcription (apart from `Function unknown`) which is interesting. It seems that some **transcription factors** within this set are important for adaptation to changing conditions, cell cycling, and so on. We can look at the transcription factors within the set of 38 genes that are different between *both* pulsed conditions, and the continuous condition.

```{r}
df_diff_fitness %>%
  filter(SP_CO & LP_CO & !SP_LP, COG_Process == "Transcription") %>%
  arrange(continuous)
```

**6 TFs have lower fitness in pulse conditions**

- H16_B2087: Response regulator, NarL-family, DNA binding (TF, nitrite/nitrate response regulator)
- H16_A3144, phcA: Transcriptional regulator, LysR-family, involved in regulation of the quorum sensing circuit and virulence factors in Ralst. solanacearum
- H16_A1177: Transcriptional regulator, GlvR-family, involved in regulation of central carbon metabolism genes EDA, EDD, glucokinase, and nagE (N-acetylglucosamine biosynthesis)
- H16_A0502: DNA-binding protein Fis (Factor for inversion stimulation), small abundant regulator in E.coli, involved in many processes like transcriptional activation of rRNA and tRNA operons, and oriC-directed DNA replication.
- H16_A0387, rpoN: RNA polymerase sigma-54 factor. the RNA-Pol regulating sigma factor for N starvation
- H16_A0310: Transcriptional regulator, GntR-family. Regulates N-acetylglucosamine biosynthesis, e.g. via nagE. Interacts with lacI family TFs (?).

**4 TFs have higher fitness in pulse conditions**

- H16_B2025: Cold shock protein, DNA binding (TF)
- H16_B1970: Response regulator, NarL-family, DNA binding (TF, nitrite/nitrate response regulator)
- H16_B1728, prtR: Transmembrane activator of PrtI, an RNA polymerase sigma subunit (ECF sigma factor, belongs to the sigma-70 factor family)
- H16_B1673: Transcriptional regulator, TetR/AcrR-family, Repressor involved in the biosynthesis of the osmoprotectant glycine betaine. It represses transcription of the choline transporter BetT and the genes of BetAB involved in the synthesis of glycine betaine.

### Heatmap of genes with strong fitness effect

To include *all genes*, we can also filter genes by a simple fitness threshold instead of the *differential* fitness, dF, gives more comprehensive results. For each sample, lower and upper fitness threshold are defined (or t-statistics) and all genes are plotted with fitness score on a heatmap.

```{r, fig.width = 9, fig.height = 3.5}
# generate colorpalette for heatmap
heat_cols <- colorspace::diverging_hcl(n = 7, h = c(260, 0), c = 100, l = c(50, 90))

# rearrange fitness data to wide format
df_heatmap <- df_fitness_summary %>% filter(Time == 8) %>%
  group_by(locus_tag) %>% filter(any(abs(Norm_fg_median) >= 3)) %>%
  ungroup %>% select(COG_Process, gene_name, Condition, Norm_fg_median) %>% 
  pivot_wider(names_from = Condition, values_from = Norm_fg_median) %>%
  select(COG_Process, gene_name, `long pulse`, `short pulse`, continuous) %>%
  mutate(COG_Process = case_when(
    grepl("Amino|Nucleotide|Coenz", COG_Process) ~ "amino acids, nucleotides, coenzymes",
    grepl("Energy", COG_Process) ~ "energy metabolism",
    grepl("Trans|Post", COG_Process) ~ "transcription, translation",
    TRUE ~ "other"
  )) %>%
  column_to_rownames(var = "gene_name")

# turn matrix into heat map, also for re-ordering
mat_heatmap <- select(df_heatmap, -COG_Process) %>% as.matrix  
reordered <- mat_heatmap %>% dist %>% hclust %>% as.dendrogram %>% 
  order.dendrogram

# plot heatmap
plot_heatmap_3 <- levelplot(mat_heatmap[reordered, ] %>% replace(., . > 6, 6) %>% replace(., . < -6, -6),
  par.settings = custom.colorblind(),
  col.regions = colorRampPalette(heat_cols)(16),
  at = seq(-6, 6, 1), aspect = "fill",
  xlab = "", ylab = "", scales = list(x = list(tck = c(1, 0), cex = 0.6, rot = 90)),
  panel = function(x, y, z, ...) {
    panel.levelplot(x, y, z, ...)
    panel.abline(h = c(1.5, 2.5), col = "white", lwd = 1.5)
  }
)

# plot color coded COG groups
plot_heatmap_4 <- xyplot(rep(1, length(continuous)) ~ seq_along(continuous), df_heatmap[reordered, ],
  groups = COG_Process, par.settings = custom.colorblind(),
  scales = list(draw = FALSE), xlab = "", ylab = "",
  xlim = c(0.25, length(reordered)+0.25), col = stdcol[c(1,2,3,4)],
  pch = 15, cex = 1.1, auto.key = list(columns = 4, cex = 0.7))

print(plot_heatmap_4, position = c(0.1,0.76,0.92,1), more = TRUE)
print(plot_heatmap_3, position = c(0,0,1,0.92))
```

```{r, include = FALSE}
#svg("../figures/figure_fitness_heat.svg", width = 9, height = 3.5, )
#print(plot_heatmap_4, position = c(0.1,0.76,0.92,1), more = TRUE)
#print(plot_heatmap_3, position = c(0,0,1,0.92))
#dev.off()
```

### Fitness per functional group

So far, the **bottom-up approach** was used to select interesting groups of genes. A threshold in fitness score (difference) was applied and the genes tested for enrichment of functional groups.
Here, we will apply the **top-down approach**, first select known groups of interest, and then compare average fitness score for the three conditions. We start with one of the most interesting features of *Ralstonia*, the *cbb* operon encoding enzymes for PPP and Calvin cycle (e.g. Rubisco). Then we look at other genes/groups of interest, like PHB synthesis, or oxidative phosphorylation.

First we come up with a generalized function to compare all genes of a pathway as a beeswarm plot, broken down by condition.

```{r}
draw_beeswarm <- function(data) {
  xyplot(Norm_fg_median ~ factor(Condition, unique(Condition)[c(1,3,2)]), data,
    groups = seq_type,
    xlab = "", ylab = "fitness", ylim = c(-1.5, 1.5),
    par.settings = custom.colorblind(), as.table = TRUE,
    between = list(x = 0.5, y = 0.5), pch = 19,
    scales = list(alternating = FALSE),
    panel = function(x, y, ...) {
      panel.grid(h = -1, v = -1, col = grey(0.9))
      panel.beeswarm(x, y, bin_y = TRUE, breaks_y = seq(-1.5,1.5, length.out = 16), ...)
      panel.key(corner = c(0.95, 0.05), cex = 0.6, points = FALSE, ...)
      panel.pvalue(x, y, pvalue = TRUE, fixed_pos = 1.6, cex = 0.6, col = 1, ...)
    }
  )
}
```


```{r, fig.width = 8, fig.height = 7.5, warning = FALSE}
# beeswarm plots
plot_cbb_fitness_bee <- df_fitness_summary %>%
  filter(Time == 8,
    (scaffold == "NC_005241.1" & start > 437500 & start < 451000) |
    (scaffold == "NC_008314.1" & start > 1547000 & start < 1564450)
  ) %>% draw_beeswarm
  
plot_phb_fitness_bee <- df_fitness_summary %>%
  filter(Time == 8, str_detect(gene_name, "^pha[A-Z]")) %>%
  draw_beeswarm

# single time series per gene
plot_cbb_fitness_time <- df_fitness %>% filter(str_detect(gene_name, "cbb.|cfx.")) %>% 
  draw_fitness_ts

plot_phb_fitness_time <- df_fitness %>% filter(str_detect(gene_name, "^pha[A-Z]")) %>%
  draw_fitness_ts


print(plot_cbb_fitness_bee, position = c(0,0.65,0.5,1), more = TRUE)
print(plot_cbb_fitness_time, position = c(0,0,0.5,0.7), more = TRUE)
print(plot_phb_fitness_bee, position = c(0.5,0.65,1,1), more = TRUE)
print(plot_phb_fitness_time, position = c(0.5,0,1,0.7))
```

```{r, include = FALSE}
svg("../figures/figure_fitness_cbb.svg", width = 8, height = 7.5)
print(plot_cbb_fitness_bee, position = c(0,0.65,0.5,1), more = TRUE)
print(plot_cbb_fitness_time, position = c(0,0,0.5,0.7), more = TRUE)
print(plot_phb_fitness_bee, position = c(0.5,0.65,1,1), more = TRUE)
print(plot_phb_fitness_time, position = c(0.5,0,1,0.7))
dev.off()
```


### Correlation of fitness and protein abundance

The competition experiment has overlapping conditions with other experiments where protein abundance was determined by MS.
Particularly, this is the condition `continuous` in the BarSeq data set (t = 8 generations), that is identical to the condition `FRC 0.1` in MS data (chemostat, fixed growth rate 0.1/h, 0.5 g/L fructose, 1 g/L NH4). We can import the MS proteomics data and see if (change in) fitness is correlated to protein abundance.

```{r}
load("../data/input/Ralstonia_eutropha.Rdata")
df_prot <- Ralstonia_eutropha; rm(Ralstonia_eutropha)

# merge the two data sets
df_prot <- df_prot %>%
  filter(condition == "FRC 0.1") %>%
  left_join(select(df_fitness_comp, locus_tag,
    tstat_median, continuous)) %>%
  
  # rename some variables for clarity
  rename(fitness_barseq = continuous, fitness_tstat = tstat_median) %>%
  
  # add category based on fitness threshold
  mutate(fitness_threshold = if_else(abs(fitness_barseq) >= 2, "fitness >= 2", "fitness < 2"))
```

Plot both variables against each other on a dotplot, and alternatively genes with differential fitness >= 2 separate from the rest as a violin plot.

```{r, fig.width = 5.6, fig.height = 3.2}
# plot fitness vs prot abundance
plot_fitness_vs_abund <- xyplot(fitness_barseq ~ log10(mean_mass_fraction*0.68), df_prot,
  groups = fitness_threshold,
  par.settings = custom.colorblind,
  pch = 19, alpha = 0.6, cex = 0.7,
  xlab = expression("m"[protein]*" [log"[10]*" g gDCW"^-1*"]"), ylab = "fitness",
  panel = function(x, y, ...) {
    panel.grid(h = -1, v = -1, col = grey(0.9))
    panel.xyplot(x, y, ...)
    panel.key(..., points = FALSE)
  }
)


boxplot_colorblind <- custom.colorblind()
boxplot_colorblind$box.rectangle$lwd = 1.5
boxplot_colorblind$box.umbrella$lwd = 1.5

# protein abundance per essentiality group
plot_fitness_vs_abund2 <- xyplot(log10(mean_mass_fraction*0.68) ~ factor(fitness_threshold), df_prot,
    par.settings = boxplot_colorblind,
    horizontal = FALSE, do.out = FALSE,
    xlab = "", ylab = expression("m"[protein]*" [log"[10]*" g gDCW"^-1*"]"),
    scales = list(alternating = FALSE, x = list(rot = 25, cex = 0.7)),
    between = list(x = 0.5, y = 0.5),
    panel = function(x, y, ...) {
      panel.grid(h = -1, v = -1, col = grey(0.9))
      panel.violin(x, y, lwd = 0, col = grey(0.6, 0.5), box.width = 0.7, ...)
      panel.bwplot(x, y, pch = "|", box.width = 0.3, ...)
      panel.pvalue(x, y, cex = 0.7, fixed_pos = -0.6, verbose = TRUE, ...)
      panel.text(1:3, -7.8, labels = paste0("n=", table(x)), cex = 0.6)
    }
  )

print(plot_fitness_vs_abund, position = c(0,0,0.5,1), more = TRUE)
print(plot_fitness_vs_abund2, position = c(0.5,0,1,1))
```

What are the most abundant genes among those with strong effect on mutant fitness?
We can create a table of the top N genes.

```{r}
df_prot %>% filter(abs(fitness_barseq) >= 2) %>%
  arrange(desc(mean_mass_fraction)) %>% ungroup %>%
  select(protein, locus_tag, Pathway, mean_mass_fraction, fitness_barseq) %>%
  slice(1:10)
```

