---
title: "Analysis of competition experiments with a barcoded transposon library"
date: "`r format(Sys.time(), '%d %B, %Y')`"
author: "Michael Jahn"
output:
  html_notebook: 
    theme: spacelab
    toc: yes
---

## Description

This R notebook is a bioinformatics pipeline to analyze fitness data obtained from a barcoded transposon library in *Ralstonia eutropha* a.k.a. *Cupriavidus necator*. For background and details regarding the method, see [Wetmore at al., mBio, 2015](https://mbio.asm.org/content/6/3/e00306-15) and [Price et al., Nature, 2018](http://www.nature.com/articles/s41586-018-0124-0)).


## Libraries

```{r, message = FALSE}
# optionally install repos from github
# devtools::install_github("m-jahn/lattice-tools")
library(lattice)
library(latticeExtra)
library(latticetools)
library(tidyverse)
library(ggvenn)
```


## Overview of barcode/transposon read counts

### Data import and processing

Read in the main data table with reads per barcode and sample ('pool counts'), and the fitness table. Tables were obtained by processing sequencing data with a custom [BarSeq pipeline](https://github.com/m-jahn/rebar).

```{r, message = FALSE}
# import barseq counts data in wide format
df_barseq <- read_tsv("../data/barseq/20201222_barseq_frc.poolcount")

# import fitness data, the final output of the BarSeq pipeline
df_fitness <- read_tsv("../data/barseq/20201222_barseq_frc.gene_fitness.tab") %>%
  mutate(Time = Time %>% str_remove(" generations") %>% as.numeric) %>%
  rename(locus_tag = locusId) %>%
  mutate(Condition = factor(Condition, c("continuous", "short pulse", "long pulse")))

# import genome annotation
df_ref <- read_csv("../data/ref/Ralstonia_H16_genome_annotation.csv") %>%
  filter(!duplicated(locus_tag))

# define standard colors
stdcol <- custom.colorblind()$superpose.line$col
```

### Summary statistics

Convert pool counts table from wide to long format first.
Generate an overview about the number of reads per barcode, barcodes per gene and so on. Around 8-10 M reads were mapped on average, per sample. The Continuous cultivation, 32 generation time point is an outlier, with a lower number of "usable" reads accoridng to the BarSeq pipeline. The total number of sequenced reads is however similar to the other samples; it is not clear yet why 50-70% of reads got discarded for the 32 generation sample.

```{r, message = FALSE}
df_barseq <- df_barseq %>%
  gather(key = "condition", value = "n_reads", matches("Cont|Long|Short"))

# Number of total mapped reads
df_barseq %>% group_by(condition) %>%
  summarize(n_million_reads = sum(n_reads)/10^6)
```

Distribution of **number of reads per barcode**. There are sufficient reads for quantification, on average log2(n) = 5 = 32 reads per barcode were used. This is better coverage then what was obtained with the TnSeq sequencing runs. 

```{r, fig.width = 8, fig.height = 5}
plot_reads_per_bc <- histogram(~ log2(n_reads) | condition,
  df_barseq, as.table = TRUE, layout = c(8,4),
  par.settings = custom.colorblind(),
  between = list(x = 0.5, y = 0.5),
  xlab = expression("log"[2]*" reads per barcode"),
  scales = list(alternating = FALSE),
  panel = function(x, ...) {
    panel.grid(h = -1, v = -1, col = grey(0.9))
    panel.histogram(x, border = "white", ...)
  }
)

print(plot_reads_per_bc)
```
Similarly to the above, this is an overview about the **number of barcodes per gene**, as a histogram.
This distribution is the same for all conditions and replicates. The second plot is the **number of reads per gene**, averaged as median over all conditions (excluding 0 time point where counts were averaged by BarSeq pipeline). The average reads per gene are log2(n) = 10, so n = 2^10 or around 1000 reads per gene.


```{r, fig.width = 7, fig.height = 3.7, message = FALSE}
plot_reads_per_bc <- histogram(~ Strains_per_gene,
  df_fitness %>% select(locus_tag, Strains_per_gene) %>% distinct %>% filter(Strains_per_gene < 40), 
  as.table = TRUE, breaks = 20,
  par.settings = custom.colorblind(),
  between = list(x = 0.5, y = 0.5), xlim=c(-2, 42),
  xlab = expression("mutants per gene"),
  scales = list(alternating = FALSE),
  panel = function(x, ...) {
    panel.grid(h = -1, v = -1, col = grey(0.9))
    panel.histogram(x, border = "white", ...)
  }
)

plot_reads_per_gene <- histogram(~ log2(reads_per_gene_median),
  df_fitness %>% filter(Time != 0) %>% group_by(locus_tag) %>%
    summarize(reads_per_gene_median = median(Counts)),
  as.table = TRUE, breaks = 20,
  par.settings = custom.colorblind(),
  between = list(x = 0.5, y = 0.5),
  xlab = expression("log"[2]*" reads per gene (med)"),
  scales = list(alternating = FALSE),
  panel = function(x, ...) {
    panel.grid(h = -1, v = -1, col = grey(0.9))
    panel.histogram(x, border = "white", ...)
  }
)

print(plot_reads_per_bc, split = c(1,1,2,1), more = TRUE)
print(plot_reads_per_gene, split = c(2,1,2,1))
```

One final technical parameter that is useful to assess the necessary sequencing depth is the number of genes that have been reliably quantified in all samples, meaning with a certain minimum number of reads. For this purpose, we exclude one empty sample `ShortPulse_32_gen` and the continuous samples 16 and 32 generations with lower read number/diversity.

```{r, fig.with = 4, fig.height = 3, message = FALSE}
df_fitness %>% filter(!((Condition == "continuous" & Time %in% c(16,32)) | 
  (Condition == "long pulse" & Time == 32 & Replicate == 4))) %>%
  group_by(locus_tag) %>%
  summarize(geq_1_reads = sum(Counts >= 1), geq_10_reads = sum(Counts >= 10), 
    geq_100_reads = sum(Counts >= 100)) %>%
  
  xyplot(sort(geq_1_reads) + sort(geq_10_reads) + sort(geq_100_reads) ~ seq_along(locus_tag), .,
    xlab = "gene", ylab = "samples with n or more reads",
    par.settings = custom.colorblind(),
    type = "l", lwd = 2,
      panel = function(x, y, ...) {
      panel.grid(h = -1, v = -1, col = grey(0.9))
      panel.xyplot(x, y, ...)
      panel.key(labels = c("n = 1", "n = 10", "n = 100"), corner = c(0.9,0.1))
    }
  )
```

## Gene fitness analysis

### Depletion over time (generations)

To track the depletion over time (several generations), it's good to keep the 0-time point samples in the same format instead of in a separate column. We move `n0` to `Counts` and fill `log2FC`, `Norm_fg` (normalized fitness per gene), and t-statisitic columns with zeroes.

TODO-List for improvements of `rebar` pipeline:
- keep 0 time point counts, plus replicates in main table
- replace 0 counts with NA by default

```{r}
df_fitness <- df_fitness %>% filter(Time == 8) %>%
  mutate(Counts = n0, .keep = "unused") %>%
  mutate(log2FC = 0, Time = 0, Norm_fg = 0, t = 0, Significant = 0) %>%
  bind_rows(select(df_fitness, -n0)) %>%
  select(-ID) %>%
  left_join(select(df_ref, locus_tag, gene_name, 
    COG_Process, eggNOG_name))
```

Now we can plot log2 FC or normalized gene fitness over generations. For this type of overview it is best to summarize individual replicates (4x) to the mean or median, per time point and condition. We also add genome annotation to the summary table.

```{r, messages = FALSE}
df_fitness_summary <- df_fitness %>% group_by(locus_tag, scaffold, Time, Condition, Strains_per_gene) %>%
  summarize(
    Norm_fg_median = median(Norm_fg, na.rm = TRUE),
    log2FC_median = median(log2FC, na.rm = TRUE),
    tstat_median = median(t, na.rm = TRUE)
  ) %>%
  left_join(df_ref)
```


```{r, fig.width = 6.5, fig.height = 5}
plot_hist_log2FC <- df_fitness_summary %>%
  group_by(Condition, locus_tag) %>% filter(all(!is.infinite(log2FC_median))) %>%
  ungroup %>% slice(1:5000) %>%
  
  xyplot(log2FC_median ~ Time | Condition, .,
    groups = locus_tag, as.table = TRUE,
    col = stdcol[1], alpha = 0.2, layout = c(3, 1),
    xlab = "", ylab = expression("log"[2]*" FC"),
    par.settings = custom.colorblind(), type = c("l"),
    between = list(x = 0.5, y = 0.5),
    scales = list(alternating = FALSE), lwd = 2,
    panel = function(x, y, ...) {
      panel.grid(h = -1, v = -1, col = grey(0.9))
      panel.xyplot(x, y, ...)
    }
  )

plot_hist_normfg <- df_fitness_summary %>%
  ungroup %>% slice(1:5000) %>%
  
  xyplot(Norm_fg_median ~ Time | Condition, .,
    groups = locus_tag, as.table = TRUE,
    col = stdcol[2], alpha = 0.2, layout = c(3, 1),
    xlab = "generations", ylab = "fitness",
    par.settings = custom.colorblind(), type = c("l"),
    between = list(x = 0.5, y = 0.5),
    scales = list(alternating = FALSE), lwd = 2,
    panel = function(x, y, ...) {
      panel.grid(h = -1, v = -1, col = grey(0.9))
      panel.xyplot(x, y, ...)
    }
  )

print(plot_hist_log2FC, position = c(0,0.47,1,1), more = TRUE)
print(plot_hist_normfg, position = c(0,0,1,0.55))
```

As sort of an internal control, compare the gene fitness obtained by a complex procedure to the log2 FC of read counts, which is a very simple measure of 'fitness'. The two variables correlate well for two out of the three conditions, but show a marked difference for "continuous". This can be related to the poorer Seq quality of the 32 generation sample.

```{r, fig.height = 3, fig.width = 6.5}
df_fitness_summary %>%
  group_by(Condition, locus_tag) %>% 
  filter(Time == 8, all(!is.infinite(log2FC_median))) %>%
  ungroup %>% slice(1:5000) %>%
  
  xyplot(Norm_fg_median ~ log2FC_median | Condition, .,
    as.table = TRUE, col = stdcol[5], pch = 19,
    alpha = 0.5, cex = 0.6, aspect = 1,
    layout = c(3, 1), xlim = c(-7,3), ylim = c(-5,5),
    xlab = expression("log"[2]*" FC"), ylab = "fitness",
    par.settings = custom.colorblind(),
    between = list(x = 0.5, y = 0.5),
    scales = list(alternating = FALSE),
    panel = function(x, y, ...) {
      panel.grid(h = -1, v = -1, col = grey(0.9))
      panel.xyplot(x, y, ...)
      panel.lmlineq(x, y, fontfamily = "FreeSans", r.squared = TRUE, ...)
      panel.abline(a = 2, b = 1, col = grey(0.5), lty = 2, lwd = 1.5)
    }
  )
```

### Comparing gene fitness between conditions

Similarly to Figure 2 in [Wetmore et al, mBIO, 2015](https://mbio.asm.org/content/6/3/e00306-15), we can investigate condition-dependent gene fitness by comparing conditions one-on-one.

```{r, fig.width = 9, fig.height = 3.3, message = FALSE}
df_fitness_comp <- df_fitness_summary %>% filter(Time == 8) %>%
  group_by(locus_tag) %>% mutate(tstat_median = min(tstat_median)) %>%
  select(locus_tag, Condition, Norm_fg_median, gene_name, COG_Process, tstat_median) %>%
  pivot_wider(names_from = Condition, values_from = Norm_fg_median)

# plot all conditions vs each other
plot_fitness_comp <- lapply(
  list(
    c("short pulse", "continuous"),
    c("long pulse", "continuous"),
    c("short pulse", "long pulse")), function(var){
  
  xyplot(get(var[1]) ~ get(var[2]),
    df_fitness_comp, groups = abs(get(var[1])-get(var[2])) > 2, #tstat_median < -3
    par.settings = custom.colorblind(), col = stdcol[c(5,1)],
    pch = 19, alpha = 0.5, cex = 0.6, aspect = 1,
    xlim = c(-7, 4), ylim = c(-7, 4),
    xlab = var[2], ylab = var[1],
    panel = function(x, y, ...) {
      panel.grid(h = -1, v = -1, col = grey(0.9))
      panel.abline(v = 0, h = 0, col = grey(0.5), lty = 2, lwd = 1.5)
      panel.abline(a = 0, b = 1, col = grey(0.5), lty = 2, lwd = 1.5)
      panel.abline(a = 2, b = 1, col = grey(0.5), lty = 2, lwd = 1.5)
      panel.abline(a = -2, b = 1, col = grey(0.5), lty = 2, lwd = 1.5)
      panel.xyplot(x, y, ...)
      panel.key(...)
    }
  )
})

print(plot_fitness_comp[[1]], position = c(0,0,0.33,1), more = TRUE)
print(plot_fitness_comp[[2]], position = c(0.33,0,0.66,1), more = TRUE)
print(plot_fitness_comp[[3]], position = c(0.66,0,1,1))
```

### Differential fitness of selected genes

Most genes correlate in fitness value between conditions. That means, only few genes have a **condition-specific fitness effect**, i.e. increase or decrease fitness of the respective strain in a condition. This section investigates specific genes and their functions that show such differential fitness between conditions.

We can define a differential fitness of 2 between conditions as a threshold value. This is arbitrary and simply encloses roughly 95% of the gene population. A more refined way would be to use a (data-dependent) statistical metric for setting a significance boundary (like confidence interval).

```{r}
# obtain list of differential fitness per gene
df_diff_fitness <- df_fitness_comp %>% mutate(
  SP_CO = abs(`short pulse`-continuous) > 2,
  LP_CO = abs(`long pulse`-continuous) > 2,
  SP_LP = abs(`short pulse`-`long pulse`) > 2
) %>% filter(any(SP_CO, LP_CO, SP_LP)) %>% ungroup

df_diff_fitness %>%
  summarize(
    sum(SP_CO, na.rm = TRUE),
    sum(LP_CO, na.rm = TRUE),
    sum(SP_LP, na.rm = TRUE))
```

Now we can identify overlaps between these gene sets and visualize them through infamous Venn diagrams.

```{r, fig.width = 5, fig.height = 5}
plot_venn <- df_diff_fitness %>% select(SP_CO, LP_CO, SP_LP) %>%
  ggplot() +
  geom_venn(aes(A = SP_CO, B = LP_CO, C = SP_LP), fill_color = stdcol) +
  coord_fixed() + 
  theme_void()

print(plot_venn)
```

### Depletion of selected genes over time

To measure depletion for more than 2 time points gives more confidence that the trends we see are real and consistent over several generations. Another question is to decide how many generations are enough to determine significant differences in fitness. To answer that question, we can look at fitness for 8, 16 and 32 generations for a selected condition and compare how many additional genes show up, each time point (or what the overlap is between time points).


```{r, fig.width = 7, fig.height = 6, message = FALSE}
# general plotting function for fitness as time series
draw_fitness_ts  <- function(data) {
  xyplot(Norm_fg ~ factor(Time) | str_extract(gene_name, "[a-zA-Z0-9_]+"), data,
    groups = Condition, as.table = TRUE, col = stdcol[c(5,3,2)],
    par.settings = custom.colorblind(), type = c("p", "l"),
    xlab = "generations", ylab = "fitness",
    pch = 19, between = list(x = 0.5, y = 0.5),
    scales = list(alternating = FALSE), lwd = 2,
    panel = function(x, y, ...) {
      panel.grid(h = -1, v = -1, col = grey(0.9))
      panel.errbars(x, y, ewidth = 0, ...)
      panel.key(...)
    }
  )
}

# select genes that are significantly depleted after 32 G
list_sign_genes_SP <- df_fitness %>% filter(Condition == "short pulse", t <= -4) %>%
  count(locus_tag) %>% pull(locus_tag)

# plot
df_fitness %>% filter(locus_tag %in% list_sign_genes_SP) %>% draw_fitness_ts

# table with number of significant genes after each number of generations
df_fitness %>% filter(
    locus_tag %in% list_sign_genes_SP,
    Condition == "short pulse") %>%
  group_by(locus_tag, Time) %>%
  summarize(t = min(t)) %>%
  group_by(Time) %>% summarize(significant_genes = sum(t <= -4), total_genes = n())
```

### Heatmap of genes with strong fitness effect

To include *all genes*, we can also filter genes by a simple fitness threshold instead of the *differential fitness dF*, which probably gives more comprehensive results. For each sample, lower and upper fitness threshold are defined (or t-statistics) and all genes are plotted with fitness score on a heatmap.

```{r, fig.width = 9, fig.height = 3.5}
# generate colorpalette for heatmap
heat_cols <- colorspace::diverging_hcl(n = 7, h = c(260, 0), c = 100, l = c(50, 90))

# rearrange fitness data to wide format
df_heatmap <- df_fitness_summary %>% filter(Time == 8) %>%
  group_by(locus_tag) %>% filter(any(abs(Norm_fg_median) >= 3)) %>%
  ungroup %>% select(COG_Process, gene_name, Condition, Norm_fg_median) %>% 
  pivot_wider(names_from = Condition, values_from = Norm_fg_median) %>%
  select(COG_Process, gene_name, `long pulse`, `short pulse`, continuous) %>%
  mutate(COG_Process = case_when(
    grepl("Amino|Nucleotide|Coenz", COG_Process) ~ "amino acids, nucleotides, coenzymes",
    grepl("Energy", COG_Process) ~ "energy metabolism",
    grepl("Trans|Post", COG_Process) ~ "transcription, translation",
    TRUE ~ "other"
  )) %>%
  column_to_rownames(var = "gene_name")

# turn matrix into heat map, also for re-ordering
mat_heatmap <- select(df_heatmap, -COG_Process) %>% as.matrix  
reordered <- mat_heatmap %>% dist %>% hclust %>% as.dendrogram %>% 
  order.dendrogram

# plot heatmap
plot_heatmap_1 <- levelplot(mat_heatmap[reordered, ] %>% replace(., . > 6, 6) %>% replace(., . < -6, -6),
  par.settings = custom.colorblind(),
  col.regions = colorRampPalette(heat_cols)(16),
  at = seq(-6, 6, 1), aspect = "fill",
  xlab = "", ylab = "", scales = list(x = list(tck = c(1, 0), cex = 0.6, rot = 90)),
  panel = function(x, y, z, ...) {
    panel.levelplot(x, y, z, ...)
    panel.abline(h = c(1.5, 2.5), col = "white", lwd = 1.5)
  }
)

# plot color coded COG groups
plot_heatmap_2 <- xyplot(rep(1, length(continuous)) ~ seq_along(continuous), df_heatmap[reordered, ],
  groups = COG_Process, par.settings = custom.colorblind(),
  scales = list(draw = FALSE), xlab = "", ylab = "",
  xlim = c(0.25, length(reordered)+0.25), col = stdcol[c(1,2,3,4)],
  pch = 15, cex = 1.1, auto.key = list(columns = 4, cex = 0.7))


print(plot_heatmap_1, position = c(0,0,1,0.92), more = TRUE)
print(plot_heatmap_2, position = c(0.1,0.76,0.92,1))
```

```{r, include = FALSE}
#svg("../figures/figure_fitness_heat.svg", width = 9, height = 3.5, )
#print(plot_heatmap_4, position = c(0.1,0.76,0.92,1), more = TRUE)
#print(plot_heatmap_3, position = c(0,0,1,0.92))
#dev.off()
```

### Fitness per functional group

So far, the **bottom-up approach** was used to select interesting groups of genes. A threshold in fitness score (difference) was applied and the genes tested for enrichment of functional groups.
Here, we will apply the **top-down approach**, first select known groups of interest, and then compare average fitness score for the three conditions. We start with one of the most interesting features of *Ralstonia*, the *cbb* operon encoding enzymes for PPP and Calvin cycle (e.g. Rubisco). Then we look at other genes/groups of interest, like PHB synthesis, or oxidative phosphorylation.

First we come up with a generalized function to compare all genes of a pathway as a beeswarm plot, broken down by condition.

```{r}
draw_beeswarm <- function(data) {
  xyplot(Norm_fg_median ~ Condition, data,
    groups = Condition, col = stdcol[c(5,3,2)],
    xlab = "", ylab = "fitness", ylim = c(-3.5, 3.5),
    par.settings = custom.colorblind(), as.table = TRUE,
    between = list(x = 0.5, y = 0.5), pch = 19,
    scales = list(alternating = FALSE),
    panel = function(x, y, ...) {
      panel.grid(h = -1, v = -1, col = grey(0.9))
      panel.abline(h = 0, lwd = 1.5, col = grey(0.7), lty = 2)
      panel.beeswarm(x, y, bin_y = TRUE, ...)
      panel.pvalue(x, y, pvalue = TRUE, fixed_pos = 1.6, cex = 0.6, col = 1)
    }
  )
}
```


```{r, fig.width = 4, fig.height = 7.5, warning = FALSE}
# beeswarm plots
plot_cbb_fitness_bee <- df_fitness_summary %>%
  filter(Time == 16, str_detect(gene_name, "cbb.|cfx.")) %>%
  draw_beeswarm

# single time series per gene
plot_cbb_fitness_time <- df_fitness %>%
  filter(str_detect(gene_name, "cbb.|cfx."), Time != 32) %>% 
  draw_fitness_ts

print(plot_cbb_fitness_bee, position = c(0,0.65,1,1), more = TRUE)
print(plot_cbb_fitness_time, position = c(0,0,1,0.7))
```
Finally export figure with selected CBB genes.

```{r, fig.width = 4.5, fig.height = 5.5}
# single time series per gene
plot_cbb_fitness_select <- df_fitness %>% filter(
  Time != 32,
  str_detect(gene_name, "cbb[LSGKP]|cbxSP|cfxR")) %>%
  mutate(gene_name = case_when(
    gene_name == "cfxR cbbR H16_B1396" ~ "cbbR (REG)",
    gene_name == "cbbKP PHG417" ~ "cbbK-P (PGK)",
    gene_name == "cbbGP PHG418" ~ "cbbG-P (GAPDH)",
    gene_name == "cfxP cbbPP PHG421" ~ "cbbP-P (PRUK)",
    gene_name == "cbxSP cbbS cbbSP cfxSP rbcS PHG426" ~ "cbbS-P (RBPC)",
    gene_name == "cbbL2 cbbL cbxLP cfxLP PHG427" ~ "cbbL-P (RBPC)"
  )) %>%
  
  xyplot(Norm_fg ~ factor(Time) | factor(gene_name, unique(gene_name)), .,
    groups = Condition, as.table = TRUE, col = stdcol[c(5,3,2)],
    par.settings = custom.colorblind(), type = c("p", "l"),
    xlab = "generations", ylab = "fitness", aspect = 0.9,
    ylim = c(-4, 4), layout = c(3, 2),
    pch = 19, between = list(x = 0.5, y = 0.5),
    scales = list(alternating = FALSE), lwd = 2,
    panel = function(x, y, ...) {
      panel.grid(h = -1, v = -1, col = grey(0.9))
      panel.errbars(x, y, ewidth = 0, ...)
      panel.key(..., cex = 0.6, points = FALSE, corner = c(0, 0.95))
    }
  )

#svg("../figures/figure_fitness_cbb.svg", width = 4.5, height = 5.5)
print(plot_cbb_fitness_bee, position = c(0.2,0.54,1,1), more = TRUE)
print(plot_cbb_fitness_select, position = c(0,0,1,0.62))
#dev.off()
```


### Correlation of fitness and protein abundance

The competition experiment has overlapping conditions with other experiments where protein abundance was determined by MS.
Particularly, this is the condition `continuous` in the BarSeq data set (t = 8 generations), that is identical to the condition `FRC 0.1` in MS data (chemostat, fixed growth rate 0.1/h, 0.5 g/L fructose, 1 g/L NH4). We can import the MS proteomics data and see if (change in) fitness is correlated to protein abundance.

```{r}
load("../data/input/Ralstonia_eutropha.Rdata")
df_prot <- Ralstonia_eutropha; rm(Ralstonia_eutropha)

# merge the two data sets
df_prot <- df_prot %>%
  filter(condition == "FRC 0.1") %>%
  left_join(select(df_fitness_comp, locus_tag,
    tstat_median, continuous)) %>%
  
  # rename some variables for clarity
  rename(fitness_barseq = continuous, fitness_tstat = tstat_median) %>%
  
  # add category based on fitness threshold
  mutate(fitness_threshold = if_else(abs(fitness_barseq) >= 2, "fitness >= 2", "fitness < 2"))
```

Plot both variables against each other on a dotplot, and alternatively genes with differential fitness >= 2 separate from the rest as a violin plot. There's no linear correlation between fitness and protein abundance of a gene. However, when genes are grouped into two groups, no effect or effect on fitness, then genes that have an effect on fitness are significantly more abundant.

```{r, fig.width = 5.6, fig.height = 3.2}
# plot fitness vs prot abundance
plot_fitness_vs_abund <- xyplot(fitness_barseq ~ log10(mean_mass_fraction*0.68), df_prot,
  groups = fitness_threshold,
  par.settings = custom.colorblind,
  pch = 19, alpha = 0.6, cex = 0.7,
  xlab = expression("m"[protein]*" [log"[10]*" g gDCW"^-1*"]"), ylab = "fitness",
  panel = function(x, y, ...) {
    panel.grid(h = -1, v = -1, col = grey(0.9))
    panel.xyplot(x, y, ...)
    panel.key(..., points = FALSE)
  }
)


boxplot_colorblind <- custom.colorblind()
boxplot_colorblind$box.rectangle$lwd = 1.5
boxplot_colorblind$box.umbrella$lwd = 1.5

# protein abundance per essentiality group
plot_fitness_vs_abund2 <- xyplot(log10(mean_mass_fraction*0.68) ~ factor(fitness_threshold), df_prot,
    par.settings = boxplot_colorblind,
    horizontal = FALSE, do.out = FALSE,
    xlab = "", ylab = expression("m"[protein]*" [log"[10]*" g gDCW"^-1*"]"),
    scales = list(alternating = FALSE, x = list(rot = 25, cex = 0.7)),
    between = list(x = 0.5, y = 0.5),
    panel = function(x, y, ...) {
      panel.grid(h = -1, v = -1, col = grey(0.9))
      panel.violin(x, y, lwd = 0, col = grey(0.6, 0.5), box.width = 0.7, ...)
      panel.bwplot(x, y, pch = "|", box.width = 0.3, ...)
      panel.pvalue(x, y, cex = 0.7, fixed_pos = -0.6, verbose = TRUE, ...)
      panel.text(1:3, -7.8, labels = paste0("n=", table(x)), cex = 0.6)
    }
  )

print(plot_fitness_vs_abund, position = c(0,0,0.5,1), more = TRUE)
print(plot_fitness_vs_abund2, position = c(0.5,0,1,1))
```



