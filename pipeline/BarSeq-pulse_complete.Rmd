---
title: "Analysis of competition experiments with a barcoded transposon library"
date: "`r format(Sys.time(), '%d %B, %Y')`"
author: "Michael Jahn"
output:
  html_notebook: 
    theme: spacelab
    toc: yes
---

## Description

This R notebook is a bioinformatics pipeline to analyze fitness data obtained from a barcoded transposon library in *Ralstonia eutropha* a.k.a. *Cupriavidus necator*. For background and details regarding the method, see [Wetmore at al., mBio, 2015](https://mbio.asm.org/content/6/3/e00306-15) and [Price et al., Nature, 2018](http://www.nature.com/articles/s41586-018-0124-0)).


## Libraries

```{r, message = FALSE}
# optionally install repos from github
# devtools::install_github("m-jahn/lattice-tools")
# devtools::install_github("m-jahn/R-tools")
library(lattice)
library(latticeExtra)
library(latticetools)
library(tidyverse)
library(dendextend)
library(Rtools)
library(colorspace)
```


## Overview of barcode/transposon read counts

### Data import and processing

Read in the main data tables with A) reads per barcode and sample ('pool counts'), and B) the fitness tables. Tables were obtained by processing sequencing data with a custom [BarSeq pipeline](https://github.com/m-jahn/rebar). The 32 generation sequencing samples are removed due to the low read count in the `continuous` samples.

```{r, message = FALSE}
# import barseq counts data in wide format and reshape to long format
df_counts_frc <- read_tsv("../../../rebar/data/20201222_barseq_frc/results/result.poolcount") %>%
  select(!matches("32gen|_32_")) %>%
  pivot_longer(
    cols = !all_of(c("barcode", "rcbarcode", "scaffold", "strand", "pos")), 
    names_to = "sample", values_to = "n_reads")

df_counts_suc <- read_tsv("../../../rebar/data/20210407_barseq_suc_for/results/result.poolcount") %>%
  pivot_longer(
    cols = !all_of(c("barcode", "rcbarcode", "scaffold", "strand", "pos")), 
    names_to = "sample", values_to = "n_reads")

# merge barcode counts tables
df_counts <- bind_rows(df_counts_frc, df_counts_suc)

# import fitness data, the final output of the BarSeq pipeline
load("../../../rebar/data/20201222_barseq_frc/results/fitness_gene.Rdata")
df_fitness_frc <- fitness_gene %>%
  filter(Condition != "long pulse", Time != 32) %>%
  mutate(ID = as.numeric(ID), Substrate = "fructose", 
    Condition = str_remove(Condition, "short "))

load("../../../rebar/data/20210407_barseq_suc_for/results/fitness_gene.Rdata")
df_fitness_suc <- fitness_gene %>%
  separate(Condition, sep = "_", into = c("Substrate", "Condition"))

# merge fitness tables
df_fitness <- bind_rows(df_fitness_frc, df_fitness_suc) %>%
  rename(locus_tag = locusId)
rm("df_fitness_frc", "df_fitness_suc", "df_counts_frc", "df_counts_suc")

# import genome annotation
df_ref <- read_csv("../data/ref/Ralstonia_H16_genome_annotation.csv") %>%
  filter(!duplicated(locus_tag))

# define standard colors
stdcol <- custom.colorblind()$superpose.line$col
```

### Summary statistics

Overview about the number of reads per barcode, barcodes per gene and so on. Around 8-10 M reads were mapped on average, per sample. 

```{r, fig.width = 8, fig.height = 8, message = FALSE}
# Number of total mapped reads
df_counts %>% group_by(sample) %>%
  summarize(n_million_reads = sum(n_reads)/10^6) %>%
  barchart(factor(sample) ~ n_million_reads, .,
    par.settings = custom.colorblind(),
    horizontal = TRUE, border = NULL,
    scales = list(y = list(cex = 0.7)),
    panel = function(x, y, ...) {
      panel.grid(h = -1, v = -1, col = grey(0.9))
      panel.barchart(x, y, ...)
    }
  )
```

Distribution of **number of reads per barcode**. There is a sufficient number of reads for quantification, on average log2(n) = 5 = 32 reads per barcode.

```{r, fig.width = 8, fig.height = 6.2}
plot_reads_per_bc <- histogram(~ log2(n_reads) | sample,
  df_counts, as.table = TRUE, layout = c(8,6),
  par.settings = custom.colorblind(),
  between = list(x = 0.5, y = 0.5),
  xlab = expression("log"[2]*" reads per barcode"),
  scales = list(alternating = FALSE),
  panel = function(x, ...) {
    panel.grid(h = -1, v = -1, col = grey(0.9))
    panel.histogram(x, border = "white", ...)
  }
)

print(plot_reads_per_bc)
```

Similarly to the above, this is an overview about the **number of barcodes per gene** as a histogram. This distribution is the same for all conditions and replicates. The second plot is the **number of reads per gene**, averaged as median over all conditions (excluding 0 time point where counts were averaged by BarSeq pipeline). The average reads per gene are log2(n) = 8, which translates to n = 2^8 or around 256 reads per gene.


```{r, fig.width = 8, fig.height = 4.2, message = FALSE}
plot_reads_per_bc <- histogram(~ Strains_per_gene,
  df_fitness %>% select(locus_tag, Strains_per_gene) %>% 
    distinct %>% filter(Strains_per_gene < 40), 
  par.settings = custom.colorblind(), breaks = 20, xlim=c(-2, 42),
  xlab = expression("mutants per gene"),
  panel = function(x, ...) {
    panel.grid(h = -1, v = -1, col = grey(0.9))
    panel.histogram(x, border = "white", ...)
    panel.ablineq(v = mean(x, na.rm = TRUE),
      fontfamily = "FreeSans", col = grey(0.5), lwd = 2, lty = 2)
  }
)

plot_reads_per_gene <- histogram(~ log2(reads_per_gene_median),
  df_fitness %>% filter(Time != 0) %>% group_by(locus_tag) %>%
    summarize(reads_per_gene_median = median(Counts)),
  par.settings = custom.colorblind(), breaks = 20,
  xlab = expression("log"[2]*" reads per gene (med)"),
  panel = function(x, ...) {
    panel.grid(h = -1, v = -1, col = grey(0.9))
    panel.histogram(x, border = "white", ...)
    panel.ablineq(v = mean(x[!is.infinite(x)]),
      fontfamily = "FreeSans", col = grey(0.5), lwd = 2, lty = 2)
  }
)

print(plot_reads_per_bc, split = c(1,1,2,1), more = TRUE)
print(plot_reads_per_gene, split = c(2,1,2,1))
```

## Gene fitness analysis

### Depletion over time (generations)

We can plot log2 FC or normalized gene fitness over generations. For this type of overview it is best to summarize individual replicates (4x) to the mean or median, per time point and condition. We also add genome annotation to the summary table. The plots shows that depletion of some strains is so strong already at 8 generations that fitness/log2 FC could not be quantified for 16 generations due to missing read counts. It is best to focus on 8 generations as because it provides a more complete picture.

```{r, messages = FALSE}
df_fitness_summary <- df_fitness %>%
  group_by(locus_tag, scaffold, Time, Condition, Substrate, Strains_per_gene) %>%
  summarize(
    Norm_fg_median = median(Norm_fg, na.rm = TRUE),
    log2FC_median = median(log2FC, na.rm = TRUE),
    tstat_median = median(t, na.rm = TRUE)
  ) %>%
  left_join(df_ref)
```


```{r, fig.width = 6.5, fig.height = 8}
plot_hist_log2FC <- df_fitness_summary %>%
  filter(all(!is.infinite(log2FC_median))) %>%
  group_by(Condition, Substrate) %>%
  slice(1:2000) %>%
  
  xyplot(log2FC_median ~ Time | Substrate * Condition, .,
    groups = locus_tag, as.table = TRUE,
    col = stdcol[1], alpha = 0.2, layout = c(3, 2),
    xlab = "", ylab = expression("log"[2]*" FC"),
    par.settings = custom.colorblind(), type = c("l"),
    between = list(x = 0.5, y = 0.5),
    scales = list(alternating = FALSE), lwd = 2,
    panel = function(x, y, ...) {
      panel.grid(h = -1, v = -1, col = grey(0.9))
      panel.xyplot(x, y, ...)
    }
  )

plot_hist_normfg <- df_fitness_summary %>%
  filter(all(!is.infinite(log2FC_median))) %>%
  group_by(Condition, Substrate) %>%
  slice(1:2000) %>%
  
  xyplot(Norm_fg_median ~ Time | Substrate * Condition, .,
    groups = locus_tag, as.table = TRUE,
    col = stdcol[2], alpha = 0.2, layout = c(3, 2),
    xlab = "generations", ylab = "fitness",
    par.settings = custom.colorblind(), type = c("l"),
    between = list(x = 0.5, y = 0.5),
    scales = list(alternating = FALSE), lwd = 2,
    panel = function(x, y, ...) {
      panel.grid(h = -1, v = -1, col = grey(0.9))
      panel.xyplot(x, y, ...)
    }
  )

print(plot_hist_log2FC, position = c(0,0.47,1,1), more = TRUE)
print(plot_hist_normfg, position = c(0,0,1,0.53))
```

As sort of an internal control, we compare the gene fitness obtained by a complex procedure to the log2 FC of read counts, which is a very simple measure of 'fitness'. The two variables correlate well all tested conditions and substrates.

```{r, fig.width = 6.5, fig.height = 5.2}
df_fitness_summary %>%
  filter(Time == 8, all(!is.infinite(log2FC_median))) %>%
  
  xyplot(Norm_fg_median ~ log2FC_median |  Substrate * Condition, .,
    as.table = TRUE, col = stdcol[5], pch = 19,
    alpha = 0.4, cex = 0.6,
    layout = c(3, 2), xlim = c(-8,3), ylim = c(-6,5),
    xlab = expression("log"[2]*" FC"), ylab = "fitness",
    par.settings = custom.colorblind(),
    between = list(x = 0.5, y = 0.5),
    scales = list(alternating = FALSE),
    panel = function(x, y, ...) {
      panel.grid(h = -1, v = -1, col = grey(0.9))
      panel.xyplot(x, y, ...)
      panel.lmlineq(x, y, fontfamily = "FreeSans", r.squared = TRUE, lwd = 1.5, 
        col.text = 1, pos = 3, offset = 5, ...)
      panel.abline(a = 2, b = 1, col = grey(0.5), lty = 2, lwd = 1.5)
    }
  )
```

### Comparing gene fitness between conditions

Similarly to Figure 2 in [Wetmore et al, mBIO, 2015](https://mbio.asm.org/content/6/3/e00306-15), we can investigate condition-dependent gene fitness by comparing conditions and substrates one-on-one. The correlation between substrates and growth regimes (continuous, pulsed) is quite different. The strongest correlation does exist for the pulsed vs continuous regime for each substrate (R = 0.64 to 0.87). And for the pulsed conditions, comparison between substrates (R = 0.62 to 0.72).

```{r, fig.width = 8, fig.height = 8, message = FALSE}
df_fitness_comp <- df_fitness_summary %>% filter(Time == 8) %>%
  group_by(locus_tag) %>% mutate(tstat_median = min(tstat_median)) %>%
  select(locus_tag, Condition, Substrate, Norm_fg_median, gene_name, COG_Process, tstat_median) %>%
  unite(Condition, Condition, Substrate) %>%
  pivot_wider(names_from = Condition, values_from = Norm_fg_median) %>%
  filter(!is.na(locus_tag))

custom_splom(df_fitness_comp %>% ungroup %>% 
  select(matches("conti|pulse")), col = grey(0.4, 0.4))
```

We can also compare selected conditions directly to identify genes enriched or depleted in several conditions.

```{r, fig.width = 8, fig.height = 8, message = FALSE}
# generalized plotting function
plot_fitness_comp <- function(data, vars){
  xyplot(get(vars[2]) ~ get(vars[1]), data,
    groups = abs(get(vars[1])-get(vars[2])) > 2, #tstat_median < -3
    par.settings = custom.colorblind(), col = stdcol[c(5,1)],
    pch = 19, alpha = 0.5, cex = 0.7, aspect = 1,
    xlim = c(-7, 4), ylim = c(-7, 4),
    xlab = vars[1], ylab = vars[2],
    panel = function(x, y, ...) {
      panel.grid(h = -1, v = -1, col = grey(0.9))
      panel.abline(v = 0, h = 0, col = grey(0.5), lty = 2, lwd = 1.5)
      panel.abline(a = 0, b = 1, col = grey(0.5), lty = 2, lwd = 1.5)
      panel.abline(a = 2, b = 1, col = grey(0.5), lty = 2, lwd = 1.5)
      panel.abline(a = -2, b = 1, col = grey(0.5), lty = 2, lwd = 1.5)
      panel.xyplot(x, y, ...)
      panel.key(...)
    }
  )
}

plot_fitness_comp(df_fitness_comp, c("continuous_formate", "pulse_formate")) %>%
  print(position = c(0,0.5,0.5,1), more = TRUE)
plot_fitness_comp(df_fitness_comp, c("continuous_fructose", "pulse_fructose")) %>%
  print(position = c(0.5,0.5,1,1), more = TRUE)
plot_fitness_comp(df_fitness_comp, c("continuous_succinate", "pulse_succinate")) %>%
  print(position = c(0,0,0.5,0.5), more = TRUE)
plot_fitness_comp(df_fitness_comp, c("continuous_formate", "continuous_fructose")) %>%
  print(position = c(0.5,0,1,0.5), more = TRUE)
```

### Differential fitness of selected genes

Most genes correlate in fitness value between conditions. That means, only some genes have a **condition-specific fitness effect**, i.e. increase or decrease fitness of the respective strain in one substrate or growth regime specifically. This section investigates specific genes and their functions that show such differential fitness between conditions. A simple comparison of one condition versus another will not be helpful as there two many possible combinations. To identify interesting sets of genes, cluster analysis can be performed.

```{r, fig.width = 10, fig.height = 2.5}
# generate colorpalette for heatmap
heat_cols <- colorspace::diverging_hcl(n = 7, h = c(260, 0), c = 100, l = c(50, 90))

# create a matrix from wide fitness data for plotting heatmap
mat_heatmap <- df_fitness_comp %>% ungroup %>%
  filter(if_any(.cols = matches("conti|pulse"), ~ !between(., -2, 2))) %>%
  select(matches("locus_tag|conti|pulse")) %>%
  # filter out NA rows, and replace extreme values
  drop_na %>% mutate(across(matches("conti|pulse"), 
    function(x) {y = replace(x, x > 6, 6); replace(y, y < -6, -6)})) %>%
  column_to_rownames(var = "locus_tag") %>%
  as.matrix

# create cluster for reordering
mat_cluster <- mat_heatmap %>% dist %>% hclust(method = "ward.D")
mat_heatmap <- mat_heatmap[order.dendrogram(as.dendrogram(mat_cluster)), c(1,4,2,5,3,6)]

# plot heatmap
levelplot(mat_heatmap,
  par.settings = custom.colorblind(),
  col.regions = colorRampPalette(heat_cols)(16),
  at = seq(-6, 6, 1), aspect = "fill",
  xlab = "", ylab = "", scales = list(x = list(draw = FALSE)),
  panel = function(x, y, z, ...) {
    panel.levelplot(x, y, z, ...)
    panel.abline(h = 1:5+0.5, col = "white", lwd = 1.5)
  }
)
```

Clustering and silhouette analysis revealed that we have 4 to 7 clusters with acceptable separation, see the plot below. Of these, several clusters stick out:

1. mutants specifically depleted in formate conditions = essential for formate
2. mutants depleted in all conditions = essential in minimal medium
3. mutants enriched in fructose growth, neutral on other substrates
4. mutants enriched in continuous regime, mostly neutral in pulsed regime
5. mutants _slightly_ depleted in continuous succinate - low priority
6. mutants _slightly_ depleted in continuous fructose - low priority
7. mutants _slightly_ depleted in various conditions - low priority

```{r, fig.width = 10, fig.height = 4}
silhouetteResult <- Rtools::silhouette_analysis(mat_heatmap, mat_cluster, 2:20)
silhouetteResult$plot.summary

# plot colored dendrogram
plot(color_branches(
  mat_cluster, k = 7,
  groupLabels = TRUE,
  col = stdcol[1:7]
))
```

### Identity of super-spreader mutants

One of the most puzzling results is the appearance (very?) fast growing mutants in some conditions. These mutants quickly enrich over only 16 generations to a volume of up to 20% of all library mutants, they "take over the culture". This phenomenon was not observed previously in experiments with the *Synechocystis* sp. PCC6803 CRISPRi repression library (Yao et al., Nature Communications, 2020). This library was based on the same principle of depletion and enrichment of mutants depending on the associated fitness contribution of that mutant.

To identify the most abundant mutants, we can select the genes from cluster 3 and 4 (most enriched mutants). These mutants show a growth regime and substrate dependent pattern, as detailed in the plot below.

```{r, fig.width = 6.5, fig.height = 4.5}
list_enriched <- vegan::cutreeord(mat_cluster, k = 7)
list_enriched %>% table

df_fitness_summary %>%
  filter(locus_tag %in% names(list_enriched)) %>%
  mutate(cluster = list_enriched[locus_tag] %>% unname) %>%
  filter(cluster %in% c(3,4)) %>%

  xyplot(Norm_fg_median ~ Time | Substrate * factor(cluster), .,
    groups = paste(locus_tag, Condition), as.table = TRUE,
    layout = c(3, 2), alpha = 0.6,
    line_col = stdcol[2+as.numeric(factor(.[["Condition"]]))],
    xlab = "generations", ylab = "fitness",
    par.settings = custom.colorblind(), type = c("l"),
    between = list(x = 0.5, y = 0.5),
    scales = list(alternating = FALSE), lwd = 2,
    panel = function(x, y, groups, subscripts, line_col, ...) {
      panel.grid(h = -1, v = -1, col = grey(0.9))
      panel.text(2, 11, labels = paste("n =", sum(x == 0)/2))
      panel.xyplot(x, y, groups = groups, subscripts = subscripts,
        col = line_col[subscripts], ...)
      panel.key(c("continuous", "pulse"), corner = c(0.05, 0.5),
        points = FALSE, lines = TRUE, col = stdcol[3:4])
    }
  )
```

**Strains enriched on fructose**

What is the identity of the enriched genes? Which ones are enriched in several conditions?
First we identify the mutants highly and specifically enriched in fructose, continuous growth regime.

```{r, fig.width = 7, fig.height = 4}
df_fitness_summary %>%
  filter(locus_tag %in% names(subset(list_enriched, list_enriched == 3))) %>%
  filter(Time == 16) %>%
  group_by(locus_tag) %>% mutate(sum_fitness = sum(Norm_fg_median)) %>%
  arrange(sum_fitness) %>%
  mutate(name = paste0(locus_tag, " | ", eggNOG_name, " | ", 
    substr(eggNOG_description, 1, 40))) %>%
  
  barchart(factor(name, unique(name)) ~ Norm_fg_median, .,
    par.settings = custom.colorblind(),
    group = paste(Substrate, Condition),
    col = c(stdcol[1], lighten(stdcol[1], 0.3), stdcol[2],
      lighten(stdcol[2], 0.3), stdcol[3], lighten(stdcol[3], 0.3)),
    border = "white", stack = TRUE,
    xlab = "cumulative fitness",
    scales = list(y = list(cex = 0.7)),
    panel = function(x, y, ...) {
      panel.grid(h = -1, v = -1, col = grey(0.9))
      panel.barchart(x, y, ...)
      panel.key(..., points = FALSE, cex = 0.6, corner = c(0.97, 0.03))
    }
  )
```

**Mechanisms enabling faster growth on fructose**

The mechanism for increased growth on fructose seems clearly different from the mechanism for faster growth in all other (mainly continuous)  conditions. For the fructose set, several genes are functionally linked suggesting a similar mechanism of action, 

1. Genes `H16_B0517` (alcohol dehydrogenase) and `H16_B1917` (aldehyde dehydrogenase): According to STRING DB, the genes are co-located i.e. either in direct proximity or in the same operon in alpha-, beta- and gamma-proteobacteria, and even cyanobcateria. BioCyc has 17 possible iso-enzymes in *Cupriavidus* for the 2-enzyme pathway "ethanol degradation 1": ethanol --> acetaldehyde --> acetyl-CoA (reverse EtOH fermentation, obtain 1 NADH per reaction) catalyzed by both genes. What could be the mechanism for improved growth/yield on fructose? Chemostats are more yield- than growth selective, this pathway is probably functional and secretes EtOH as a fermentation product; KO of this pathway probably increases yield.

2. Two genes are involved in nitrate respiration/reduction, `PHG269` or narK, and `H16_B2087`, a NarL-family response regulator. NarK is a nitrate transporter, and NarL senses nitrate and then activates transcription of its targets by binding the DNA. According to [this paper on NarL by Ruanto et al., 2020](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC7419079/), "the Regulon DB database [11] for transcription regulation in E. coli lists 26 gene regulatory regions where NarL has a direct effect on transcript initiation, and it functions as an activator at 11 of these".

3. Genes involved in translation/protein folding/sulphur metabolism:
    - `H16_B2521`, Alpha-ketoglutarate-dependent taurine dioxygenase; taurine is a sulphur carrier
    - `H16_A2861`, Glutathione S-transferase; Posttranslational modification, protein turnover, chaperones
    - `H16_A1138`, Thioredoxin; Posttranslational modification, protein turnover, chaperones
    - `H16_A1336`, yogA/tdcF, putative translation initiation inhibitor,yjg Ffamily; Translation, ribosomal structure and biogenesis
    - `H16_A2553`, cO, DNA repair protein RecO; Involved in DNA repair and RecF pathway recombination

4. Several other gene products are presumably regulatory proteins:
    - `16_A0310`, transcriptional regulator, GntR-family; Transcription
    - `H16_B2215`, HTH lysR-type domain-containing protein; helix turn helix DNA binding motif

**Strains enriched in several conditions**

```{r, fig.width = 7, fig.height = 6.5}
df_fitness_summary %>%
  filter(locus_tag %in% names(subset(list_enriched, list_enriched == 4))) %>%
  filter(Time == 16) %>%
  group_by(locus_tag) %>% mutate(sum_fitness = sum(Norm_fg_median)) %>%
  arrange(sum_fitness) %>%
  mutate(name = paste0(locus_tag, " | ", eggNOG_name, " | ", 
    substr(eggNOG_description, 1, 40))) %>%
  
  barchart(factor(name, unique(name)) ~ Norm_fg_median, .,
    par.settings = custom.colorblind(),
    group = paste(Substrate, Condition),
    col = c(stdcol[1], lighten(stdcol[1], 0.3), stdcol[2],
      lighten(stdcol[2], 0.3), stdcol[3], lighten(stdcol[3], 0.3)),
    border = "white", stack = TRUE,
    xlab = "cumulative fitness",
    scales = list(y = list(cex = 0.7)),
    panel = function(x, y, ...) {
      panel.grid(h = -1, v = -1, col = grey(0.9))
      panel.barchart(x, y, ...)
      panel.key(..., points = FALSE, cex = 0.6, corner = c(0.97, 0.03))
    }
  )
```

**Mechanisms enabling faster growth in several conditions**

The picture for these strains is more clear then for the fructose-enriched strains. 13 out of 27 enriched genes (48%), among them some of the most enriched, are directly involved in hydrogenase activity, i.e. hydrogen oxygenation (hoxA, hoxF, hoxU, hoxX, hypA, hypB, hypC, hypD hypE, hypF, hyaA, hyaB, hupH).

The second theme is enrichment of ptsI (`H16_A0326`) and ptsH (`H16_A0325`), together the entire functional unit of the PTS system, the PEP-dependent sugar phosphotransferase system (sugar PTS). "This major carbohydrate active-transport system catalyzes the phosphorylation of incoming sugar substrates concomitantly with their translocation across the cell membrane. Enzyme I transfers the phosphoryl group from (PEP) to the phosphoryl carrier protein (HPr)."

Other interesting mechanisms: KO of RNA polymerase sigma factor RpoS (`H16_A2373`) seems to have a beneficial effect on steady state growth, as well as other stress related transcription factors like cold shock protein capB (`H16_B2205`), and scoF (`H16_B0002`).

```{r}
filter(df_ref, locus_tag %in% (names(subset(list_enriched, list_enriched == 4)))) %>% pull(eggNOG_name)
```


**Sanity checks**

All above results are based on fitness score, which is not much more than a normalized log2 fold change of read count over time.
We can compare if the mutants with extremely high fitness scores are also the ones that are super-abundant at the final time point, ie.e. have an average read count of >= 500,000. In fact, only 3 genes have such an extreme maximum read count, but 9 have more than 100,000 reads.

```{r}
df_fitness %>% filter(Time == 16, locus_tag %in% (subset(list_enriched, list_enriched %in% c(3,4)) %>% names)) %>%
  group_by(locus_tag) %>% summarize(max_counts = max(Counts), max_fitness = max(Norm_fg)) %>%
  arrange(desc(max_counts))
```

On the other hand, we can check which genes have an extremely high read count (>= 500,000 in *any* condition) and see if this correlates with high fitness score. It does partly. 3 out of 7 high abundant genes enrich extremely over time. The other enrich too, but only 2^1 = 2 to 2^3.5 = 11 times. These non-enriching super-abundant mutants are:

  - `H16_A0774` - cphA, Cyanophycin synthase. Supposed mechanism: enriches in LB medium as it does not turn Asp
    into cyanophycin. No benefit on minimal medium.
  - `H16_B2570` - fecA, Outer membrane receptor for Fe(III). Supposed mechanism: regulator activity together with fecR, but also 
    transmembrane transporter for siderophores. KO reduces sensitivty to excess iron??
  - `H16_A3145` - Conserved protein/domain typically associated with flavoprotein oxygenases, DIM6/NTAB family. 
    Supposed mechanism: unknown.

```{r}
df_fitness %>% filter(Time == 16, Counts > 5*10^5) %>%
  group_by(locus_tag) %>% summarize(max_counts = max(Counts), max_fitness = max(Norm_fg)) %>%
  arrange(desc(max_counts))
```




### Depletion of selected genes over time

One question is to decide how many generations are sufficient to determine significant differences in fitness. It seems that a second time point such as 16 generations helps to judge if fitness effects are consistent or not. If several time points are available, one can also fit a linear model and compare ANOVA p values and R^2. Here we plot genes that have a **low fitness in all fructose conditions** i.e. that are essential in fructose minimal medium, but not complete medium (the condition the library was created with). The threshold for consistent depletion is fitness <= -2 in all three conditions after 8 generations.


```{r, fig.width = 7, fig.height = 6, message = FALSE}
# general plotting function for fitness as time series
draw_fitness_ts  <- function(data) {
  xyplot(Norm_fg ~ factor(Time) | str_extract(gene_name, "[a-zA-Z0-9_]+"), data,
    groups = Condition, as.table = TRUE, col = stdcol[c(5,3,2)],
    par.settings = custom.colorblind(), type = c("p", "l"),
    xlab = "generations", ylab = "fitness",
    pch = 19, between = list(x = 0.5, y = 0.5),
    scales = list(alternating = FALSE), lwd = 2,
    panel = function(x, y, ...) {
      panel.grid(h = -1, v = -1, col = grey(0.9))
      panel.errbars(x, y, ewidth = 0, ...)
      panel.key(...)
    }
  )
}

# look at genes with differential fitness, remove 16 gen continuous time point
# as it shows low read number / low quality
df_fitness_comp %>%
  filter(continuous <= -2 & `short pulse` <= -2 & `long pulse` <= -2) %>%
  select(locus_tag) %>% inner_join(df_fitness) %>%
  filter(!(Time == 16 & Condition == "continuous")) %>%
  draw_fitness_ts

# export genes that are essential for growth on fructose (but not LB)
df_fitness_comp %>%
  filter(continuous <= -2 & `short pulse` <= -2 & `long pulse` <= -2) %>%
  write_csv("../data/output/essentiality_fructose.csv")
```


### Fitness per functional group

So far, the **bottom-up approach** was used to select interesting groups of genes. A threshold in fitness score (difference) was applied and the genes tested for enrichment of functional groups.
Here, we will apply the **top-down approach**, first select known groups of interest, and then compare average fitness score for the three conditions. We start with one of the most interesting features of *Ralstonia*, the *cbb* operon encoding enzymes for PPP and Calvin cycle (e.g. Rubisco). Then we look at other genes/groups of interest, like PHB synthesis, or oxidative phosphorylation.

First we come up with a generalized function to compare all genes of a pathway as a beeswarm plot, broken down by condition.

```{r}
draw_beeswarm <- function(data) {
  xyplot(Norm_fg_median ~ Condition, data,
    groups = Condition, col = stdcol[c(5, 2)],
    xlab = "", ylab = "fitness", ylim = c(-3.5, 3.5),
    par.settings = custom.colorblind(), as.table = TRUE,
    between = list(x = 0.5, y = 0.5), pch = 19,
    scales = list(alternating = FALSE),
    panel = function(x, y, ...) {
      panel.grid(h = -1, v = -1, col = grey(0.9))
      panel.abline(h = 0, lwd = 1.5, col = grey(0.7), lty = 2)
      panel.beeswarm(x, y, bin_y = TRUE, spread = 0.13, ...)
    }
  )
}
```

The cbb mutants for chromosome 2 seem to have a more positive fitness score compared to their counter parts on the pHG1 megaplasmid. However, the four genes with higher fitness show suspicious jumps from 8 to 16 hours. A  look up in the summary table revealed that they have only 1 or 2 mutants quantified per gene, which makes the results less reliable, particularly for the continuous condition with the low read problem at 16 gen. It is better to exclude these mutants. The pHG1 copies have 4,5,6 and 6 mutants respectively.

```{r, fig.width = 7.5, fig.height = 2.7}
# beeswarm plots
plot_cbb_fitness_bee <- df_fitness_summary %>%
  filter(Condition != "short pulse", 
    Time == 16, str_detect(gene_name, "cbb.|cfx.|cbx.")) %>%
  mutate(Condition = Condition %>% str_replace("long ", "") %>% factor) %>%
  draw_beeswarm

# single time series per gene
plot_cbb_fitness_select <- df_fitness %>% 
  filter(
    Condition != "short pulse",
    str_detect(gene_name, "(cbb|cfx|cbx)[PSLZKGATE]P|cbbR")) %>%
  mutate(
    Condition = Condition %>% str_replace("long ", "") %>% factor,
    gene_name = case_when(
      gene_name == "cfxR cbbR H16_B1396" ~ "cbbR (REG)",
      gene_name == "cfxP cbbPP PHG421" ~ "cbbP (PRUK)",
      gene_name == "cbxSP cbbS cbbSP cfxSP rbcS PHG426" ~ "cbbS (RBPC)",
      gene_name == "cbbL2 cbbL cbxLP cfxLP PHG427" ~ "cbbL (RBPC)",
      gene_name == "cbbZP PHG419" ~ "cbbZ (PGP)",
      gene_name == "cbbKP PHG417" ~ "cbbK (PGK)",
      gene_name == "cbbGP PHG418" ~ "cbbG (GAPDH)",
      gene_name == "cbbAP PHG416" ~ "cbbA (FBA)",
      gene_name == "cbbTP PHG420" ~ "cbbT (TKT)",
      gene_name == "cbxXP cfxXP PHG425" ~ "cbbX (RBCA)",
      gene_name == "cbbEP cfxE PHG423" ~ "cbbE (RPE)"
    ) %>% factor(., unique(.)[c(1,7,9,10,5,3,4,2,6,8)])
  ) %>%
  
  xyplot(Norm_fg ~ factor(Time) | gene_name, .,
    groups = Condition, as.table = TRUE, col = stdcol[c(5,2)],
    par.settings = custom.colorblind(), type = c("p", "l"),
    xlab = "generations", ylab = "fitness",
    ylim = c(-4, 4), layout = c(5, 2),
    pch = 19, between = list(x = 0.5, y = 0.5),
    scales = list(alternating = FALSE), lwd = 2,
    panel = function(x, y, ...) {
      panel.grid(h = -1, v = -1, col = grey(0.9))
      panel.errbars(x, y, ewidth = 0, ...)
      panel.key(..., cex = 0.6, points = FALSE, corner = c(0, 0.95))
    }
  )

print(plot_cbb_fitness_bee, position = c(0,0.03,0.35,1.1), more = TRUE)
print(plot_cbb_fitness_select, position = c(0.3,0,1.03,1.1))
```

```{r, include = FALSE}
svg("../figures/figure_fitness_cbb.svg", width = 7.5, height = 2.7)
print(plot_cbb_fitness_bee, position = c(0,0.03,0.35,1.1), more = TRUE)
print(plot_cbb_fitness_select, position = c(0.3,0,1.03,1.1))
dev.off()
```
